# Structs, Built-In Modules, Behaviors, and Protocols

## Setup

```elixir
require Integer
```

## Overview

Have you ever heard the expression "Reinventing the wheel?". Essentially it means repeating
a useless action or solving an already solved problem.

In programming, it's important to avoid reinventing the wheel, and instead rely on previously
existing solutions. Sometimes those previously existing solutions are our own!

In the previous lesson you learned about how to use modules and functions in order to 
abstract away generic and reusable behavior.

We also talked about polymorphism. Polymorphic code maintains consistent behavior while changing
the underlaying implementation.

In this lesson, you'll learn about more constructs and built-in tools Elixir provides to enable
reusable code and polymorphic code.

In this lesson we'll talk about:

* Custom reusable data structures with **Structs**.
* Reusable pre-built functionality with **Built-In Elixir Modules**.
* Polymorphic code with **Behaviours**.
* Polymorphic code with **Protocols**.

## Structs

We've learned how to abstract behavior in our programs, but what about data?

It's often useful to be able to create a custom data structure. That's what structs are for.
**Struct** is simply a short word for structure. They are an extension on top of maps that enforce
constraints on your data.

### Defining a Struct

Let's say you're building a family tree but this time, you want to make sure that every
`Person` has a name. You could define a struct with the :name key

```elixir
defmodule Person do
  defstruct [:name]
end
```

You'll notice that structs are defined using modules! the only new concept here is the `defstruct` construct.

`defstruct` is an Elixir keyword that means "this module is a struct". it accepts a single `list` of
the keys in the struct.

### Using a Struct

Remember, a struct is essentially a custom data structure that we've defined. You create instances
using `%STRUCT{}` syntax that looks very similar to how you create a map.

```elixir
%Person{}
```

You'll notice that the struct has a name key, but no value since we didn't provide anything.

Here's how you can pass in a name.

```elixir
%Person{name: "Peter Parker"}
```

So, why not just use a map? We could easily define a similar map and it looks exactly the same.

```elixir
%{name: "Peter Parker"}
```

There are a ton of reasons to use a struct vs a map. It's not possible in this section to cover
all of them.

One main reason, is that it guarantees certain keys exist (even if their value is nil), and that other's don't. 
Notice how `map.name` results in an error, but `struct.name` simply returns nil.

```elixir
map = %{}
map.name
```

```elixir
struct = %Person{}
struct.name
```

We also guarantee that other keys don't exist. For example, if we don't define `age` on our person struct,
it can't be set. This helps ensure we use the data structure as intended.

```elixir
defmodule Person do
  defstruct [:name]
end

%Person{age: 20}
```

We also get some very handy features such as default values using a keyword list.

```elixir
defmodule Person do
  defstruct name: "Peter Parker"
end

%Person{}
```

It's common to validate data in a struct. For example, you can use the @enforce_keys
module attribute to enforce that certain keys are set, other wise the struct will throw an error
**the following keys must also be given when building struct Person: [:name]**.

```elixir
defmodule Person do
  @enforce_keys [:name]
  defstruct [:name]
end

%Person{}
```

Right now, we can create a Person struct who has a name of 25. That doesn't really make much sense.

```elixir
defmodule Person do
  defstruct [:name]
end

%Person{name: 25}
```

So you can imagine it's useful to validate the data in a struct upon creation.
It's a common pattern to create a `new` function in the struct that handles creation and validation.

Here's how we could use the `is_bitstring/1` guard from earlier to ensure that name is only ever a string.
You'll notice we return a tuple with `:ok` and the struct. This is part of a common pattern to
communicate with code that the `Person` was created successfully.

Now, our code will give us an error if we misuse the `Person` struct! Excellent.

```elixir
defmodule Person do
  defstruct [:name]

  def new(name) when is_bitstring(name) do
    {:ok, %Person{name: name}}
  end
end

Person.new(25)
```

### Functions a Struct module.

A module that defines a `struct` is still a regular module as well.

You can define functions as usual.

```elixir

```

### Your Turn

* Define a new struct `Hero`.
* A `Hero` will have a `:hero_name`, `:catchphrase`, and `secret_identity`
* create a `reveal/1` function which takes in an instance of a hero and returns
  `"I am secretly #{hero.secret_identity}"`
* create an `introduce/2` function which takes in an instance of a hero and a greeting
  and returns `"#{greeting} I am #{hero.secret_identity}"`

```elixir

```

Once you've created the struct in the cell above, you can test it's working with the following.

```elixir
spider_man = %Hero{
  name: "Spider Man",
  catchphrase: "I'm just your friendly neighborhood Spiderman!",
  secret_identity: "Peter Parker"
}
```

```elixir
Hero.reveal(spider_man)
```

```elixir
Hero.introduce(spider_man, "hello!")
```

## Built-In Elixir Modules

Elixir provides a great deal of built-in behavior in common modules.

There is far to much available for you to master each module in depth. However, it's useful to
be aware of them and where to look when you're reaching for some specific functionality.

Modules group related functions together, and in general, each data type has a module 
associated with it where elixir provides a variety of functions for that data type.

<!-- livebook:{"break_markdown":true} -->

### The Kernel Module

The [Kernel](https://hexdocs.pm/elixir/1.13.2/Kernel.html#functions) is the core of everything Elixir. It provides all of functionality that
Elixir is built upon.

Even the basic operators that you've been using are simply an alternative syntax to using functions in
the Kernel.

```elixir
Kernel.+(3, 3)
```

The Kernel has many useful functions for determining a value's type such as `is_map/1`.

```elixir
Kernel.is_map(%{})
```

Functions in the Kernel module can be accessed directly without using the `Kernel.` namespace.

```elixir
is_map(%{})
```

The Kernel is fairly large and overwhelming to look at. Remember, your goal for this section is not
to remember every function of every module. Instead, you'll develop familiarity over time and with
practice.

It's more important to know that the Elixir standard library exists, and that you use 
it's many useful functions and modules.

Every developers most fundamental skill is the ability to learn and lookup information 
when you need it, not memorize a list of functions.

<!-- livebook:{"break_markdown":true} -->

### Your Turn

Try using the `is_atom/1`, `is_bitstring/1`, and `is_integer/1` functions.
use `%{}`, `"hello"`, and `2` as an argument to each.

```elixir

```

### The Integer Module

The [Integer](https://hexdocs.pm/elixir/1.13.2/Integer.html#functions) module contains functionality related to Integers.

It's time to confess, we've been making you determine if a number is even or odd the hard way.

Integer provides an `is_even/1` and `is_odd/1` function.

```elixir
Integer.is_even(3)
```

```elixir
Integer.is_odd(3)
```

### Your Turn

Use the `Integer.to_string/1` function to convert `"2"` to an integer.

```elixir

```

Try using the `Integer.gcd/2` function to determine the greatest common denominator of 
`10` and `15`. The greatest common divisor (GCD) is the largest 
positive integer that divides both 10 and 15 evenly.

<details>
<summary>Hint</summary>
the result of `Integer.gcd(10, 15) should be 5
</details>

```elixir

```

### The String Module

<!-- livebook:{"break_markdown":true} -->

The [String](https://hexdocs.pm/elixir/1.13.2/String.html#functions) module contains functionality related to strings.

Here's a few common functions to get you started.

* `at/2` get the value at the index of a string.
* `contains?/2` check if a string contains a value
* `capitalize/2` capitalize first word in a string and leaves the rest lowercase.
* `split/1` split the string into a list of words.
* `trim/2` remove whitespace from a string.
* `upcase/2` upcase a string so it is ALL CAPS

### Your turn

Use the `String.at/2` function to get the character at index 2 of "hello".

You might not yet be familiar with strings and indexes.
You can imagine a string like a list of characters

```mermaid
flowchart TB
  subgraph Characters
    S
    T
    R
    I
    N
    G
  end
  subgraph Indexes
    direction TB
    S --- 0
    T --- 1
    R --- 2
    I --- 3
    N --- 4
    G --- 5
  end
```

So to get the character at index 1 in `"hello"` would be `"e"`.

```mermaid
flowchart TB
  subgraph Characters
    H
    E
    L1[L]
    L2[L]
    O
  end
  subgraph Indexes
    direction TB
    H --- 0
    E --- 1
    L1 --- 2
    L2 --- 3
    O --- 4
  end
```

<!-- livebook:{"break_markdown":true} -->

Enter your answer in the Elixir cell below.

```elixir

```

### The Map Module

The [Map](https://hexdocs.pm/elixir/1.13.2/Map.html#functions) module contains functionality related to maps.

Here's a few common functions to get you started.

* `get/3` retrieve values in a map.
* `put/3` put a value into a map.
* `keys/1` list the keys in a map.
* `delete/2` remove a key and value from a map.
* `merge/2` merge two maps together.
* `values/1` list the values in a map.

### Your turn

Try using `Map.merge/2` to combine `%{one: 1}` and `%{two: 2}`.

```elixir

```

### Date and DateTime

Elixir provides useful built-in structs. You'll become familiar with the `Date` and `DateTime` modules
if you ever need to work with time in your programs.

Both represent a date in a calendar, however `DateTime` provides increased specificity by also
storing the time of the day. Thus `Date` and `DateTime`.

You can create a new `Date` the same way you would create any struct. It accepts a `:year`, `:month`,
and `:day`

```elixir
%Date{year: 2001, month: 8, day: 10}
```

### Your Turn

Try creating a `Date` for your birthday, if you don't want to use your birthday you can use
any day you like.

```elixir

```

### Sigils

Woah, what is `~D[2001-08-10]`? Well that's how Elixir internally represents dates. 
It uses a construct called a `sigil`. A sigil is an alternative syntax for working with 
certain types of values.

You don't yet need to be deply familiar with how sigils work, but it's useful to be aware of them.
A sigil is defined with a tilde `~` character followed by a character. In this case the `~D`
is for a `Date`. You can create a Date directly with this syntax.

```elixir
~D[2001-08-10]
```

### Your Turn

Create the same data as you did above. This time, use the `~D[]` syntax.

<!-- livebook:{"break_markdown":true} -->

### Date.new/4

Often when creating dates, it's beneficial to use the built-in `Date.new/4` function which
validates the date when creating it.

Otherwise, you can create some pretty wacky dates!

```elixir
%Date{year: 20222, month: 143, day: 123}
```

You can see the above is not valid when using `Date.new/4`. it returns `{:error, :invalid_date}`

```elixir
Date.new(20222, 143, 123)
```

## Behaviors

Behaviors allow us create modules that all share a common pattern, but need different implementations.

You can define a behavior, and then two other modules will implement it.

```mermaid
flowchart
  A[Behavior] --> B[Module]
  A[Behavior] --> C[Module]
```

This enforces that both modules will implement a shared **application programming interface** 
or **API**. What is an API? Well, in this specific context the API is the set of 
public facing functions in a module. More generically an interface is the point at which two systems
interact. Since we're talking about systems for programming applications, we call it the application
programming interface.

To define a behavior, we start by defining a module. However instead of implementing
functions, we create `@callback` module attributes. These @callback module attributes 
define the signature of a function.

The signature of a function is the name, params, and expected return value, but not the implementation.
Essentially, it's the expected input, and output types in our program, but not the actual
implementation.

To define the expected return value we use `::` and then the data type we expect to return.
Elixir provides a set of types. You can see the full list of types in the [Typespecs](https://hexdocs.pm/elixir/1.13.2/typespecs.html#basic-types)
documentation. For now, we're going to use the `String.t()` type. Some other common
types are `atom()`, `boolean()`, `integer()`, `float()`, and `any()` if you don't require a specific output.

```elixir
defmodule Villain do
  @callback catchphrase() :: String.t()
end
```

Now a module can use the `Villain` behavior using the `@behavior` module attribute.
You'll notice that Elixir displays a warning because the `DarthVader` module is supposed
to implement a `catchphrase/0` function.

```elixir
defmodule DarthVader do
  @behaviour Villain
end
```

To remove the warning, we need to implement `my_function/0` and it should return a string.

```elixir
defmodule DarthVader do
  @behaviour Villain
  def catchphrase do
    "No, I am your father."
  end
end

DarthVader.catchphrase()
```

So, why use a behavior?

Primarily, behaviors ensure that any module that implements the behavior provides the expected set
of functions and that those functions match the expected function signatures.

Behaviors are another way to achieve `polymorphism`. We can define
a behavior, and then several different modules can implement that behavior. Behaviours
allow us to create "templates" for modules to ensure each module is consistent.

The **caller**, which is the place in the code where we call a module's function, can
then have a consistent experience between modules.

```mermaid
flowchart
  A --> C
  A --> D
  A --> E
  A --> F
  C --> B
  D --> B
  E --> B
  F --> B

  A[Caller]
  B[Behaviour]
  C[Implementation]
  D[Implementation]
  E[Implementation]
  F[Implementation]
```

If the behavior ever needs to change, we can modify the behavior, and know which modules
need to be updated thanks to the warnings Elixir provides.

There are other reasons such as [Dynamic Dispatching](https://elixir-lang.org/getting-started/typespecs-and-behaviours.html#dynamic-dispatch)
Which allow the caller to deal with a single module, and swap out the implementation.

```mermaid
flowchart
  A --> B
  B --> C
  B --> D
  B --> E
  B --> F
  A[Caller]
  B[Behaviour]
  C[Implementation]
  D[Implementation]
  E[Implementation]
  F[Implementation]
```

But that's beyond the scope of this lesson.

### Your Turn

In the Elixir cell below

* Create a behaviour called Pet. a Pet should have a `@callback` module attribute `speak/0`
  function that returns a string.
* Create a module `Dog` that uses the `Pet` behaviour.
* Implement a `speak` function in the `Dog` module that returns `"woof"`.

```elixir

```

## Protocols

In english, a protocol means a set of rules or procedures. In Elixir, a protocol allows us to 
create a common functionality, with different implementations.

You might think that sounds a lot like behaviours. They are similar, because
they both enable polymorphism. However, behaviors handle polymorphism based on modules,
and protocols enable polymorphism based on data.

```mermaid
flowchart
  A -- data --> B
  B --> C
  B --> D
  B --> E
  B --> F

  A[Caller]
  B[Protocol]
  C[Implementation]
  D[Implementation]
  E[Implementation]
  F[Implementation]
```

### Create an Adder protocol

Let's create a protocol `Adder` that's going to add two values together.

This awesome adder protocol is going to hide the specifics of which
operator is necessary to add different types. So it will handle adding integers,
strings, and

<!-- livebook:{"force_markdown":true} -->

```elixir
Adder.add(1, 2)
3

Adder.add("hello, ", "world")
"hello, world"

Adder.add([1], [2])
[1, 2]
```

So if we give the protocol an integer, it will use the implementation for `Integer`.

```mermaid
flowchart
  A -- Integer --> B
  B -- Integer --> C
  B -- BitString --> D
  B -- List --> E
  style C color:green
  style D color:red
  style E color:red
  A[Caller]
  B[Adder Protocol]
  C[Integer Implementation]
  D[String Implementation]
  E[List Implementation]
```

We define a protocol using `defprotocol` and otherwise the protocol will look just a lot like a 
behaviour. Protocols do not require a typespec, however we do still
define a function clause.

```elixir
defprotocol Adder do
  def add(value, value)
end
```

We've defined a protocol above, but we haven't implemented it yet, so it's impossible to
call the `Adder.add/2` function. Notice the error for `Adder.add/2` called with two integers says 
`protocol Adder not implemented for 1 of type Integer`

```elixir
Adder.add(1, 2)
```

To define an implementation for a protocol, we use `defimpl` and provide it the name of the protocol.
We also declare what struct or data type the protocol is `for:`

```elixir
defimpl Adder, for: Integer do
  def add(int1, int2) do
    int1 + int2
  end
end

Adder.add(1, 2)
```

We also want the `Adder` protocol to handle strings and lists. That means we need to create
an implementation for List and String. In Elixir, the underlaying type for strings is `BitString`.

```elixir
defimpl Adder, for: BitString do
  def add(string1, string2) do
    string1 <> string2
  end
end

Adder.add("hello, ", "world")
```

### Your turn

In the Elixir cell below, create an implementation of Adder for lists, then call `Adder.add([1], [2])` to ensure it works.
To give you a hint, the protocol implementation will be for `List`

```elixir

```
