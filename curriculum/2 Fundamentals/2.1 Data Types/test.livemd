


You can visualize a range as representing an ascending or descending list of integers.

On it's own, it might not seem like much. But ranges will be incredibly usefull in future lessons.
We'll give you a taste of the future and show you how you can convert a range into a list.

Don't worry, we don't expect you to understand this code yet, but it's useful to understand
the relationship between `1..5` and `[1, 2, 3, 4, 5]`

```elixir
Enum.to_list(1..5)
```

Ranges can have a step. The step is that each number in the range increments or decrements by.

Represent the step of the range using `//` like so:

<!-- livebook:{"force_markdown":true} -->

```elixir
0..10//2
```

That means the range `0..10//2` correlates to the list `[0, 2, 4, 6, 8, 10]`

Here's the same range converted into a list to help you visualize it. Once again, you will
learn more about what `Enum.to_list` is in a future lesson.

```elixir
Enum.to_list(0..10//2)
```

### Your Turn

In the Elixir cell below, create a range from `3` to `9` with a step of `3`.
## Tuples

Tuples are fixed size containers for multiple elements. 
Like lists they can contain any data type.

<!-- livebook:{"force_markdown":true} -->

```elixir
{}
{7}
{1, 2, 3}
{"example"}
{1, "pizza", 3, :success, false}
```

They are often used when you know the number of desired elements and their type.
For example, it's common in Elixir to use tuples to represent failure or success cases
with the associated error message or success value.

<!-- livebook:{"force_markdown":true} -->

```elixir
{:success, "Well done!"}
{:error, "Too bad!"}
```

### Lists vs Tuples

You might notice that tuples and lists seem very similar, and they are. They are both
data types that contain a collection of elements.

The major difference is performance. Both are good at different things. In Elixir,
it's fast to retrieve an element from a tuple, however it's slow to add a new element in.

Why? Well that requires some understanding of how memory workes in a computer.
The short version is that a tuple is stored continuously all together. So, you know where
each element is on the computer.

<!-- livebook:{"break_markdown":true} -->

```mermaid
flowchart
  1[location 1] --- T
  2[location 2] --- U
  3[location 3] --- P
  4[location 4] --- L
  5[location 5] --- E
```

<!-- livebook:{"break_markdown":true} -->

However, if you want to add a new element in that means you have
to move the location of every element.

Lists on the other hand have the opposite strengths and weaknesses. Lists are stored
as **linked-lists** which means each element in the list knows the location of the next element.

<!-- livebook:{"break_markdown":true} -->

```mermaid
flowchart LR
  L -- location of I --> I -- location of S --> S -- location of T --> T
```

<!-- livebook:{"break_markdown":true} -->

So we can store elements in a list anywhere, if we need to add or remove a new element
we only have to change the location one element is pointing to.

However, we don't know the location of every element upfront like with a tuple, so if you
want to get the third element, you need to look through the first and second to find it.

### Your Turn

In the Elixir cell below, create a tuple with `:ok` as the first element, and `"got it!"` as
the second element.

## Keyword Lists

Keyword lists belong to a category of data structures known as **associative data structures**.
That's because keyword lists allow you to associate values in the list with a key.

Elements in a keyword lists are broken up into two parts, a key, and a value. That's why
you'll also often hear it refered to as a **key-value data structure**.

In Elixir, the key is an atom, and the value can be any data structure, even another keyword list.

<!-- livebook:{"force_markdown":true} -->

```elixir
[key: "value"]
[atom: "anything!"]
["You can use quotes for the atom key!": ""]
[snake_case_is_convention: ""]
[ButThatIsNotEnforced: ""]
```

Keys in a keyword list do not have to be unique.

<!-- livebook:{"force_markdown":true} -->

```elixir
[my_key: "value", my_key: "value"]
```

Elixir allows you to work with keyword lists in this nice `[key: "value"]` syntax. However,
keyword lists are actually just a list of tuples where the first element is an atom.

<!-- livebook:{"force_markdown":true} -->

```elixir
[{:key, "value"}]
```

In the Elixir cell below, you can see how Elixir converts lists of tuples matching the `{:atom, value}` syntax
into a keyword list.

```elixir
[{:key, "value"}, {:key, "value"}]
```

If you break the convention in the keyword list, Elixir reverts to displaying
the keyword list as a list of tuples.

```elixir
[{}, key: "value"]
```

List order is guaranteed, so the same is true for keyword lists.

### Your Turn

In the Elixir cell below, create a keyword list of your favourite super hero. Include their `:name` and `:secret_identity`.

```elixir

```

## Maps

Maps are another type of associative data structure. Infact maps are the common go-to for a key-value
data structure. You can create a map using `%{}`. Similar to keyword lists they can have atoms as keys and then any value.

<!-- livebook:{"force_markdown":true} -->

```elixir
%{key: "value"}
```

However, unlike keyword lists, keys must be unique otherwise they will be overwritten.
Elixir is very helpful and provides a warning to let us know we're overriding a duplicate key.

```elixir
%{duplicate_key: "value1", duplicate_key: "value2"}
```

Unlike keyword lists, maps do not guarantee key order, which is why you'll notice the returned value of the map below
does not have the same order as the map created.

```elixir
%{one: "one", two: "two", three: "three"}
```

Keyword lists suffer from the same problems as lists if you want to access an element in the middle
of the list, where as maps are designed to access elements quickly. You'll learn more about how to
access elements in a map in a future lesson.

Unlike keyword lists, maps can have any values as the key. Commonly you will see atom-key maps

<!-- livebook:{"force_markdown":true} -->

```elixir
%{atom_key: "value"}
```

And also string-key maps.

<!-- livebook:{"force_markdown":true} -->

```elixir
%{"string key" => "value"}
```

However, the key to a map could be anything! even another map! You will need to use the `=>` symbol
though, not a colon `:`. `=>` is an equals sign `=` and a greater than symbol `>`.

<!-- livebook:{"force_markdown":true} -->

```elixir
%{[1,2,3] => "value"}
%{%{example: "my_example"} => "value"}
%{1 => "value"}
```

### Your Turn

Since this is the last exercise in the lesson, let's say `:goodbye` `"world"` and call it a day!

In the Elixir cell below, create a map with the key `:goodbye` and the value `"world"`.

```elixir

```