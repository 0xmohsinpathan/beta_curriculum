# Lesson 1: Elixir Data Types

## Setup

Ensure that you evaluate all code using the `ea` keybinding. Press the `e` then the `a` key.

```elixir
Mix.install([{:kino, github: "livebook-dev/kino"}])
```

## Overview

Elixir and other programming languages allow you to represent information as data.
What does that mean?  Our job as programmers is often to translate project requirements 
into something that a computer understands. However, while computers can do computations in only a few seconds that would
take our entire lives, they only
do what we tell them to. So we have to provide incredibly explicit instruction.

The great thing about computers is they do what we tell them to. But, unfortunately, that means if something goes wrong, it's usually our fault.

Check out the 
[Exact Instructions Challenge: Peanut Butter and Jelly](https://www.youtube.com/watch?v=cDA3_5982h8&ab_channel=JoshDarnit) for a messy example!

To provide instruction to the computer, you need to understand the language it speaks.
Well, that's not entirely true. The actual language the computer speaks is in electrical signals 
represented as 0s and 1s. This is called **binary**. Instead of writing programs in binary
We have programming languages like **Elixir** that allow use to write instructions in
more or less plain English with some special words, characters, and restrictions.

Some programming languages look more like plain English, and other's definitely don't. 
There's even a programming language that let's you [write a program as a cow](https://esolangs.org/wiki/COW)!

```
MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO
 MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO
 MoO MoO Moo MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO Moo MoO MoO
 MoO MoO MoO MoO MoO Moo Moo MoO MoO MoO Moo OOO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO
 MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO Moo MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO
 MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO
 MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO
 MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO Moo MOo
 MOo MOo MOo MOo MOo MOo MOo MOo MOo MOo MOo MOo MOo MOo MOo MOo MOo MOo MOo MOo MOo MOo MOo MOo MOo MOo MOo MOo MOo MOo MOo MOo MOo MOo MOo
 MOo MOo MOo MOo MOo Moo MOo MOo MOo MOo MOo MOo MOo MOo Moo MoO MoO MoO Moo MOo MOo MOo MOo MOo MOo Moo MOo MOo MOo MOo MOo MOo MOo MOo Moo
 OOO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO MoO Moo 
```

Some programming languages operate closer to the machine code the computer uses, 
these are called **low-level programming languages**. They are great for optimizing
performance but often much harder to read and understand.

Alternatively, other programming languages improve developer's quality of life by operating closer to human language. These languages are referred to as **high level programming languages**.
Elixir is a high-level programming language. It's developer-friendly and powerful.

Whatever programming language you're using, you need to understand how to convert real-world concepts
into instructions the computer understands. This lesson is going to focus on exactly that.
So, how do we represent real-world information as something the computer understands? The answer
is **data**. Depending on what type of information we want in the program, we use different **data types**.

For example, on your social media profile (Linkedin, Twitter, Instagram, etc), you often have to
store your name, birthday, and some of your interests.

Your name might be in a data type called a **string**.

<!-- livebook:{"force_markdown":true} -->

```elixir
"Peter Parker"
```

The same goes with the month you were born.

<!-- livebook:{"force_markdown":true} -->

```elixir
"August"
```

Sometimes we can use different data types to represent the same information. For example,
August is the 10th month, so we could use an **integer** instead.

<!-- livebook:{"force_markdown":true} -->

```elixir
10
```

You will learn all of the data types below and what kinds of information they are good
at representing. Don't worry; this is just an overview of what you're about to learn.
You are not expected to be familiar with any of these data types yet.

* **Booleans** `true` and `false` values.
* **Integers** whole positive and negative numbers such as `1`, `345`, `0`, and `-98`.
* **Floats** pisitive and negative decimal numbers such as `1.3`, `31.54`, `0.0`, and `-65.2`.
* **Strings** text information such as `"Hello, world!"`.
* **Atoms** constants who's name is their value such as `:ok` and `:error`.
* **Lists** lists of information such as `[1, 2, 3]`.
* **Tuples** store multiple items of a known size `{5, 2, 1}`.
* **Ranges** ascending or descending series of numbers with a step such as `1..10`.
* **Keyword Lists** lists of information with associated keys and values `[hello: "world"]`
* **Maps** a key-value data structure `%{hello: "world"}`

## Booleans

Programming languages hide the internal details of how computers work. This allows us as
developers to think at a high level. However, it's still useful to be aware of some of the inner workings.

Under the hood, computers store electrical signals. You can think of this like powering a 
lightbulb but on a much smaller scale. An electrical signal is either **on** or **off**, and by manipulating
these electrical signals, we are able to create complex information and instruction.

You may have seen movies or tv series that show coding as a bunch of `1`s and `0`s
![](images/binary.jpg). A 0 represents a signal that's **off** and a `1` represents a signal
that's **on**. These `0`s and `1`s are called **binary**.

After we write our Elixir code, our instructions are then converted or **compiled** into binary.
**binary** is the machine code that the computer actually understands.

So, you might wonder how we go from `0`s and `1`s to creating rockets, websites, self-driving
cars, smartphones, and 3D animations.

Well let's take the first step with booleans. A boolean (BOO-LEE-AN). 
is a `true` or a `false` value. Conceptually, this is a direct representation of
`on` and `off` in your program.

There are only two booleans.

<!-- livebook:{"force_markdown":true} -->

```elixir
true
false
```

### Turn on the Power!

Since booleans represent something that is `on` or `off` it makes sense to use them to
turn on the power! We've set up a program that displays a light. We need you to power it on.
replace `false` with `true`.

```elixir
power = false

# TODO - Hide
content = if power, do: "/images/on.png", else: "/images/off.png"
image = Kino.Image.new(File.read!(__DIR__ <> content), :png)
```

## Integers

### Integers

Integers are whole numbers, that also include negative numbers.

<!-- livebook:{"force_markdown":true} -->

```elixir
1
1023
1235460
-1
-100
-123512
```

Often you'll use integers for representing ages, days, years, cash values and more.

<!-- livebook:{"break_markdown":true} -->

### Your turn

In the Elixir cell below, enter the biggest number you can think of.
If you've used any other programming language, you might be surprised! Integers
in Elixir are unbounded, meaning they have no maximum size.

Contrast that with a language like JavaScript which as a maximum integer size of `9007199254740991`
Elixir makes that look tiny!

```elixir

```

## Floats

**Floats** refer to **floating-point numbers**.

Floats are used to represent decimal numbers in your program like `1.22`, `2.3`, `1.0`, and even `0.0`.
Just like for integers, floats are represented in binary. Any numbers to the right of the `.` uses
binary to represent decimal numbers.

<!-- livebook:{"force_markdown":true} -->

```elixir
0.0
```

The number of digits after the decimal point is known as the **precision** of the float.
For example, the precision of the float `1.2` is one. the precision of the float `1.22` is two.

You'll often use floats for representing percentages.
For example, you might want to represent a progress bar as a percentage.

Almost done!

<!-- livebook:{"force_markdown":true} -->

```elixir
99.4
```

Take great care when performing calculations with floats. 
Computers are limited to how precise they can be when representing floating-point numbers. 
Therefore, it's possible to have rounding errors.

```elixir
1.2 + 1.4
```

Evaluate the above and you'll notice that `1.2 + 1.4` is not `2.6`, but `2.5999999999999996`. 
Computerphile has an [excellent video on why](https://www.youtube.com/watch?v=PZRI1IfStY0&ab_channel=Computerphile).

It's for this reason it's not recommended to use floats for representing money, even though
it might seem intuitive to do so. Often you'll use integers to represent pennies, or some other contruct
specifically for money.

For our purposes, it's enough to be aware of this, without understanding the internal reasons for why this occurs.

<!-- livebook:{"break_markdown":true} -->

### Your Turn

In the Elixir cell below, enter some floating-point addition that returns an unexpected result.

```elixir

```

## Strings

A string is any sequence of characters contained within two double quotes "".
A character is any single number, letter, or symbol.

<!-- livebook:{"force_markdown":true} -->

```elixir
"T" # letters
"t" # letters
"1" # numbers
"1.2" # numbers
"&" # symbols
"_" # symbols
```

You can visualizize a string as characters joined together by strings.
Strings can be a single character, no characters, or many characters!

```mermaid
flowchart LR
  S --- T --- R --- I --- N --- G
```

Strings can contain single quotes and other symbols such as !@#$%^&*()_+-=';: and more.

<!-- livebook:{"force_markdown":true} -->

```elixir
"!@#$%^&*()_+-=';:"
```

They are useful for representing all kinds of information as text.

### Your Turn

In the Elixir cell below, create a string "Hello, world!". This is a right of passage for every 
programmer.

```elixir

```

## Atoms

Atoms are named constants. In other words, their name is their value.

Atoms are often used to represent common constants in your program.
For example, they often represent the :success or :error of a program.

<!-- livebook:{"force_markdown":true} -->

```elixir
:success
:error
```

They might also be used to represent the state of some action. For example:

<!-- livebook:{"force_markdown":true} -->

```elixir
:completed
:in_progress
:starting
```

You might wonder why we have both strings and atoms, because they seem to do the same thing.
One primary reason, is performance. Atoms are stored in an **atom table** and can be referenced by an integer.
This makes it way faster to check if two atoms are equal.

What is an **atom table**? Imagine it like an excel spreadsheet.
Each value has a numbered key, so checking `1 = 1` is a lot easier than checking.
`"HeLloWorld = HeLloWorLd"`.

Atoms are defined using a colon `:` and a series of letters, digits, and certain valid symbols.

### Rules for Naming Atoms

There are specific rules for naming atoms, but fortunately you don't need
to memorize them! Instead, pay attention to the colors in your code. 
If you define an atom incorrectly, you'll notice that it's no longer blue.

Here are some valid atoms:

<!-- livebook:{"force_markdown":true} -->

```elixir
:hello
:my_atom1
```

Here are some invalid atoms, notice they are mostly white:

<!-- livebook:{"force_markdown":true} -->

```elixir
:$this_is_invalid
:!this_is_invalid
:2
:@
:$
:?
:invalid # spaces are not valid
```

Sometimes languages establish conventions. Conventions are common patterns of doing things which
the community agrees upon. 
For example, In Elixir it's convention to name atoms lowercase names separated by underscores.

While the following will work:

<!-- livebook:{"force_markdown":true} -->

```elixir
:MY_ATOM!
```

It's unconventional.

```elixir
:MY_ATOM
```

You can use quotes with atoms to avoid name rules.

<!-- livebook:{"force_markdown":true} -->

```elixir
:"$Now we don't have to follow any rules. This is a valid atom (though unconventional)"
```

<!-- livebook:{"break_markdown":true} -->

### Nil

We use `nil` when we want to represent a lack of something. In other programming languages it's 
equivalent might be `undefined`. It's useful when you expect some value, but it doesn't exist yet.
You'll sometimes see exercises use `nil` to show where to put your answer for example.

Under the hood, `nil` is actually an atom `:nil`.

We can use `===` to verify that `:nil` and `nil` are actually the same value.

```elixir
nil === nil
```

The same goes for `true`, and `false`. They are
all atoms but omit the colon `:`.

```elixir
true === true
```

```elixir
false === false
```

### Erlang

Atoms in Elixir are also used to provide access to Erlang tools.
If you're not already familiar, Erlang is the low level language that Elixir is built on. 
It contains a collection of useful tools

For example, there is the `:math` module, which has math related functionality.

Here's how you can get pi from the :math module.

```elixir
:math.pi()
```

You will learn more about how to use Erlang through atoms in future lessons. It's enough for
now to be aware that Erlang tools can be accessed through certain atoms.

### Your Turn

In the Elixir cell below, create an atom of your favorite element. Mine is `:hydrogen` 
because it likes to get along with everyone.

You can find the full list of elements [here](https://ptable.com/?lang=en#Properties).

```elixir

```

## Lists

Lists are exactly what they sound like, they are lists of information.
Lists contain a sequence of any other data type, even themselves. Use square brackets `[]` to
create a list, and then separate each value with a comma `,`.

For example:

<!-- livebook:{"force_markdown":true} -->

```elixir
[1, 2, 3]                           # A list of integers
["a", "b", "c"]                     # A list of strings
[1, "b", 2]                         # A list of integers and strings
[1.2, true, false, 3123, "b^&e8*"]  # A list of floats, booleans, integers, and strings.
[]                                  # an empty list
[[], []]                            # a list of empty lists
[[1,2,3], [3,2,1]]                  # a list of lists with numbers
[[[]], [], [[], []]]                # deeply nested lists are valid, but often hard to read!
```

Lists are used to represent a collection of information. For example, a shopping list, a to-do list,
or a list of tags on an article. Values in a list are often referred to as `elements`.

### Indexes

An **index** is the position of an element in a list.

In programming, we count indexes starting at 0. Why? The short answer is,
it relates to how computer hardware works.

So take this example list.

<!-- livebook:{"force_markdown":true} -->

```elixir
["a", "b", "c"]
```

* `"a"` is at index `0`
* `"b"` is at index `1`
* `"c"` is at index `2`

### Your Turn

In the Elixir cell below, Create a list of your favourite foods as strings.

```elixir

```

## Ranges

**Ranges** Ranges are useful for representing an ascending or descending sequence of numbers, without needing
to manually type each number in a list.

such as 1 to 10

<!-- livebook:{"force_markdown":true} -->

```elixir
1..10
```

```mermaid

flowchart LR
  1 --> 2 --> 3 --> 4 --> 5 --> 6 --> 7 --> 8 --> 9 --> 10
```

or 5 to -5.

<!-- livebook:{"force_markdown":true} -->

```elixir
5..-5
```

```mermaid
flowchart LR
  5 --> 4 --> 3 --> 2 --> 1 --> 0 --> -1 --> -2 --> -3 --> -4 --> -5
```

You can visualize a range as representing an ascending or descending list of integers.

On it's own, it might not seem like much. But ranges will be incredibly useful in future lessons.
We'll give you a taste of the future and show you how you can convert a range into a list.

Don't worry, we don't expect you to understand this code yet, but it's useful to understand
the relationship between `1..5` and `[1, 2, 3, 4, 5]`

```elixir
Enum.to_list(1..5)
```

Ranges can have a step. By default ranges have a step of `1` so the include each whole number 
between the left number before the `..` and the right number after the `..`.

You can override the default step of the range using `//`:

<!-- livebook:{"force_markdown":true} -->

```elixir
0..10//2
```

<!-- livebook:{"force_markdown":true} -->

```elixir
0 --> 2 --> 4 --> 6 --> 8 --> 10
```

That means the range `0..10//2` correlates to the list `[0, 2, 4, 6, 8, 10]`

Here's the same range converted into a list to help you visualize it. Once again, you will
learn more about what `Enum.to_list` is in a future lesson.

```elixir
Enum.to_list(0..10//2)
```

### Your Turn

In the Elixir cell below, create a range from `3` to `9` with a step of `3`. 
Replace `nil` with your answer.

```elixir
Enum.to_list(nil)
```

## Tuples

Tuples are fixed size containers for multiple elements. 
Like lists they can contain any data type.

<!-- livebook:{"force_markdown":true} -->

```elixir
{}
{7}
{1, 2, 3}
{"example"}
{1, "pizza", 3, :success, false}
```

They are often used when you know the number of desired elements and their type.
For example, it's common in Elixir to use tuples to represent failure or success cases
with the associated error message or success value.

<!-- livebook:{"force_markdown":true} -->

```elixir
{:success, "Well done!"}
{:error, "Too bad!"}
```

### Your Turn

In the Elixir cell below, create a tuple with `:ok` as the first element, and `"got it!"` as
the second element.

```elixir

```

## Keyword Lists

Keyword lists are lists with keys. Each key associates with a value.

```mermaid
flowchart
  key1: --> Value1
  key2: --> Value2
  key3: --> Value3
```

Keyword lists belong to a family of data types known as **associative data structures**.
you'll also often hear it referred to as a **key-value data structure**.

In Elixir, the key is an atom, and the value can be any data structure, even another keyword list.

<!-- livebook:{"force_markdown":true} -->

```elixir
[key: "value"]
[atom: "anything!"]
["You can use quotes for the atom key!": ""]
[snake_case_is_convention: ""]
[ButThatIsNotEnforced: ""]
```

Keys in a keyword list do not have to be unique.

<!-- livebook:{"force_markdown":true} -->

```elixir
[my_key: "value", my_key: "value"]
```

Elixir allows you to work with keyword lists in this nice `[key: "value"]` syntax. However,
keyword lists are actually just a list of tuples where the first element is an atom.

<!-- livebook:{"force_markdown":true} -->

```elixir
[{:key, "value"}]
```

In the Elixir cell below, you can see how Elixir converts lists of tuples matching the `{:atom, value}` syntax
into a keyword list.

```elixir
[{:key, "value"}, {:key, "value"}]
```

If you break the convention in the keyword list, Elixir reverts to displaying
the keyword list as a list of tuples.

```elixir
[{}, key: "value"]
```

List order is guaranteed, so the same is true for keyword lists.

### Your Turn

In the Elixir cell below, create a keyword list of your favourite super hero. Include their `:name` and `:secret_identity`.

```elixir

```

## Maps

Maps are another type of associative data structure. In fact maps are the common go-to for a key-value
data structure. You can create a map using `%{}`. Similar to keyword lists they can have atoms as keys and then any value.

<!-- livebook:{"force_markdown":true} -->

```elixir
%{key: "value"}
```

However, unlike keyword lists, keys must be unique; otherwise they will be overwritten.
Elixir is very helpful and provides a warning to let us know we're overriding a duplicate key.

```elixir
%{duplicate_key: "value1", duplicate_key: "value2"}
```

Unlike keyword lists, maps do not guarantee key order, which is why you'll notice the returned value of the map below
does not have the same order as the map created.

```elixir
%{one: "one", two: "two", three: "three"}
```

Keyword lists suffer from the same problems as lists if you want to access an element in the middle
of the list, where as maps are designed to access elements quickly. You'll learn more about how to
access elements in a map in a future lesson.

Unlike keyword lists, maps can have any values as the key. Commonly you will see atom-key maps

<!-- livebook:{"force_markdown":true} -->

```elixir
%{atom_key: "value"}
```

And also string-key maps.

<!-- livebook:{"force_markdown":true} -->

```elixir
%{"string key" => "value"}
```

However, the key to a map could be anything! even another map! You will need to use the `=>` symbol
though, not a colon `:`. `=>` is an equals sign `=` and a greater than symbol `>`.

<!-- livebook:{"force_markdown":true} -->

```elixir
%{[1,2,3] => "value"}
%{%{example: "my_example"} => "value"}
%{1 => "value"}
```

### Your Turn

Since this is the last exercise in the lesson, let's say `:goodbye` `"world"` and call it a day!

In the Elixir cell below, create a map with the key `:goodbye` and the value `"world"`.

```elixir

```
