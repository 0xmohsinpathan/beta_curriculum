# Control Flow

## Setup

```elixir
Mix.install([
  {:kino, "~> 0.5.1"}
])
```



## Pattern Matching

In many other programming languages, the match operator `=` is called an assignment operator.

That makes sense, because so far you've only seen the `=` used to bind values to variables.
However Elixir actually uses **Pattern Matching** and binding instead of assignment.

What is pattern matching? Well rather than simply assigning values to variables, Elixir allows
you to bind variables on the left-hand side of the `=`. So long as it matches the same shape of the
right hand side of the `=`.

What does that mean? Well, we already know we can use `=` to bind the right hand side value to a variable.

```elixir
my_tuple = {1, 2, 3}
```

But did you know that you can also pattern match like this?

```elixir
{one, two, three} = {1, 2, 3}

two
```

You can create an expression on the left-hand side, and so long as it matches the shape
of the data on the right-hand side, you can extract and **match** on internal values.
Here's the same concept with a list

```elixir
[hero, secret_identity] = ["Spider Man", "Peter Parker"]

hero
```

This binds a new variable. If you aren't concerned about a value then you can use underscore `_`
to avoid binding it to a named variable.

```elixir
[_, secret_identity] = ["Spider Man", "Peter Parker"]

secret_identity
```

However, if the left hand side doesn't match the right hand side, then the code will crash with 
a **MatchError**.

```elixir
[name] = ["Spider Man", "Peter Parker"]
```

You can pattern match with any kind of data. So long as the left side matches the right side.

### Your Turn

Replace the variable with a **pattern match** expression to bind every internal value to a new
variable. The first exercise is filled out as an example. Choose any variable name.

```elixir
%{spiderman: identity1} = %{spiderman: "Peter Parker"}
```

```elixir
variable = ["A"]
```

```elixir
variable = {"A", "B"}
```

```elixir
variable = [hello: "world"]
```

## Pattern Matching with Case

Previously, we talked about how the case statement checks for equality.

```elixir
case "same" do
  "same" -> "this will return"
end
```

We're also able to use pattern matching for case statements. The first valid match will execute,
and you can use the variables you assign in the instruction.

```elixir
case [1, 2] do
  [] -> nil
  [one] -> one
  [one, two] -> one + two
end
```

### Your turn

Trigger the `"A"`, `"B"`, `"C"`, and `"D"` cases by changing `my_variable`.

```elixir
my_variable = []

case my_variable do
  [] -> nil
  [1, 2, 3] -> "A"
  %{one: _} -> "B"
  {1, 2, 3, %{hello: "world"}} -> "C"
  10 -> "D"
end
```

## Pattern Matching Multi-Clause Functions

You've already learned about using multi-clause functions with different arity's or different guards.
You can also create multi-clause functions with pattern matching.

```elixir
defmodule Greeter do
  def greet([name1, name2]) do
    "Hello, #{name1} and #{name2}"
  end

  def greet(%{name: name, identity: identity}) do
    "Hi #{identity} err..I mean #{name}"
  end

  def greet(name) do
    "Hello, #{name}"
  end
end
```

```elixir
Greeter.greet("Peter")
```

```elixir
Greeter.greet(["Peter", "Bruce"])
```

```elixir
Greeter.greet(%{name: "Batman", identity: "Bruce Wayne"})
```

## With

`with` is often used together with pattern matching to create "happy path" code.
It's useful whenever you have a series of cases or values that rely on eachother.

You can use with to create check some pre-conditions before executing instructions.

```mermaid
flowchart LR
  with --> 1
  1 --> 2
  2 --> 3
  3 --> 4
  1[pre-condition]
  2[pre-condition]
  3[pre-condition]
  4[instruction]
```

If any of the preconditions fail, the with statement will stop and return the value 
of the failed pre-condition.

```mermaid
flowchart LR
  1[pre-condition]
  2[pre-condition]
  3[pre-condition]
  4[instruction]
  with --> 1
  1 --> 2
  2 --> 3
  3 --> 4
  1 --> 5[failed pre-condition]
  2 --> 5
  3 --> 5
```

Alternatively, you can use `else` to handle the result of a failed precondition.

```mermaid
flowchart LR
  1[pre-condition]
  2[pre-condition]
  3[pre-condition]
  4[instruction]
  with --> 1
  1 --> 2
  2 --> 3
  3 --> 4
  1 --> 5[failed pre-condition]
  2 --> 5
  3 --> 5
  5 --> 6[else]
```

<!-- livebook:{"break_markdown":true} -->

Here's a minimal example `with` with a single pre-condition.

```elixir
is_admin = true

with true <- is_admin do
  "delete user"
end
```

The `with` statement checks is_admin. if `true`, it returns `"delete_user"`.
if any other value, it returns the value of is_admin.

```mermaid
flowchart LR
  with --> is_admin --> 3[delete user]
  is_admin --> 4[is_admin]
```

<!-- livebook:{"break_markdown":true} -->

`with` uses pattern maching to check if the left side of the `<-` matches the right side.
The example above is probably better served using a simple `if` statement, so let's make the example
more realistic and store `is_admin` in a boolean on a user map.

```elixir
user = %{is_admin: true}

with true <- user do
  "delete user"
end
```

Because `%{is_admin: true}` does not match `true`, the with statement returns `%{is_admin: true}`.
Let's correct that.

```elixir
user = %{is_admin: true}

with %{is_admin: true} <- user do
  "delete user"
end
```

Great! That's working. But this is still probably better handled by an `if` or `case` statement.

```elixir
user = %{is_admin: true}

if user === %{is_admin: true} do
  "delete user"
end
```

With is specifically really good for checking a series of pre-conditions.
Let's change our example to sending an email. To send an email we need to ensure:

* the sending user is an admin
* the recieving user has an email
* the email has a title and a body

We also need the `name` of the sender and reciever, and their emails.
If we were to use `case`, here's what that might look like. It's an unclear mess!

```elixir
sending_user = %{name: "Batman", email: "notbrucewayne@bat.net", is_admin: true}
recieving_user = %{name: "Robin", email: "boywonder@bat.net"}
email = %{title: "ROBIN!", body: "WE'RE OUT OF BAT SNACKS!"}

case sending_user do
  %{is_admin: true, name: sender_name, email: sender_email} ->
    case recieving_user do
      %{name: reciever_name, email: reciever_email} ->
        case email do
          %{title: title, body: body} ->
            "from #{sender_name}:#{sender_email} to #{reciever_name}:#{reciever_email} #{title}, #{body}"
        end
    end
end
```

Here's the same code rewritten using `with`. There's still some natural complexity, but it's 
a fair bit more clear.

```elixir
sending_user = %{name: "Batman", email: "notbrucewayne@bat.net", is_admin: true}
recieving_user = %{name: "Robin", email: "boywonder@bat.net"}
email = %{title: "ROBIN!", body: "WE'RE OUT OF BAT SNACKS!"}

with %{is_admin: true, name: sender_name, email: sender_email} <- sending_user,
     %{name: reciever_name, email: reciever_email} <- recieving_user,
     %{title: title, body: body} <- email do
  "from #{sender_name}:#{sender_email} to #{reciever_name}:#{reciever_email} #{title}, #{body}"
end
```

Right now, if a value doesn't match the precondition, it returns the value. for example,
if the sender is `nil` we return `nil`

```elixir
sending_user = nil
recieving_user = %{name: "Robin", email: "boywonder@bat.net"}
email = %{title: "ROBIN!", body: "WE'RE OUT OF BAT SNACKS!"}

with %{is_admin: true, name: sender_name, email: sender_email} <- sending_user,
     %{name: reciever_name, email: reciever_email} <- recieving_user,
     %{title: title, body: body} <- email do
  "from #{sender_name}:#{sender_email} to #{reciever_name}:#{reciever_email} #{title}, #{body}"
end
```

Sometimes it's useful to simply return the value, other times it's useful to handle the error. 
When we want to handle the error you can use `else`. The else block works like a `case`
statement here were we match on the return value of the pre-condition.

```elixir
sending_user = "batman"
recieving_user = %{name: "Robin", email: "boywonder@bat.net"}
email = %{title: "ROBIN!", body: "WE'RE OUT OF BAT SNACKS!"}

with %{is_admin: true, name: sender_name, email: sender_email} <- sending_user,
     %{name: reciever_name, email: reciever_email} <- recieving_user,
     %{title: title, body: body} <- email do
  "from #{sender_name}:#{sender_email} to #{reciever_name}:#{reciever_email} #{title}, #{body}"
else
  error -> "Email not sent because #{error} did not match expected format"
end
```

Much like a `case` statement, you can match on multiple cases to handle different errors.

```elixir
sending_user = %{name: "Joker", email: "joker@jokesonyou.haha"}
recieving_user = %{name: "Robin", email: "boywonder@bat.net"}
email = %{title: "ROBIN!", body: "WE'RE OUT OF BAT SNACKS!"}

with %{is_admin: true, name: sender_name, email: sender_email} <- sending_user,
     %{name: reciever_name, email: reciever_email} <- recieving_user,
     %{title: title, body: body} <- email do
  "from #{sender_name}:#{sender_email} to #{reciever_name}:#{reciever_email} #{title}, #{body}"
else
  %{name: "Joker"} -> "Get out of here Joker!"
  error -> "Email not sent because #{error} did not match expected format"
end
```

### Your turn

In the Elixir cell below

* create a variable scores that is a list `[5, 10, 20]`
* create a with statement that checks that `scores` has 3 elements and through pattern matching
  binds each to a variable.
* in the body of the with statement, add each number together.

```elixir

```

## Expected Errors

Now that you understand control flow and pattern matching, you're ready to tackle error handling.

Computers are nearly perfect. However, humans are not. Errors and bugs are part of life as
a programmer.

Sometimes we can anticipate potential errors. 
For example, what happens when you try to create a Date with an invalid month?

```elixir
Date.new(1998, 122, 21)
```

The module function returns an error tuple `{:error, :invalid_date}`.

For the errors that we expect, Elixir developers established a pattern of using
`:error` and `:ok` tuples.

```elixir
Date.new(1998, 12, 21)
```

Functions that anticipate errors return either
 `{:ok, data}` or `{:error, reason}`

<!-- livebook:{"break_markdown":true} -->

```mermaid
flowchart
  Function --> OK
  Function --> Error
  Error["{error: reason}"]
  OK["{ok: data}"]
```

<!-- livebook:{"break_markdown":true} -->

This allows us to call these functions, and then use pattern matching to handle the `:ok` or `:error`
case.

<!-- livebook:{"break_markdown":true} -->

```mermaid
flowchart
  Caller --- Function
  Caller --> A[ok instructions]
  Caller --> B[error instructions]
  Function --> Output
  Output --- ERROR["{:error, reason}"]
  Output --- OK["{:ok, data}"]
```

<!-- livebook:{"break_markdown":true} -->

The `Date` module expects that we'll sometimes call it with mismatched integers and it handles that
error specifically.

<!-- livebook:{"break_markdown":true} -->

This enables predictable error handling. We can use `case` to match on the `:error` and `:ok` tuples,
then handle them however is appropriate.

```elixir
case Date.new(1998, 12, 21) do
  {:ok, date} -> date
  {:error, reason} -> reason
end
```

### Your Turn

In the Elixir cell below, trigger the `:error` case by changing `Date.new(1998, 12, 21)` to an invalid
date.

```elixir
case Date.new(1998, 12, 21) do
  {:ok, value} -> value
  {:error, reason} -> reason
end
```

### Your Turn

Create a function `convert_to_12_hour`
which takes in an integer from 1 to 24. It will then return the equivalent time
on a 12 hour clock.

* 1 would become `{:ok, "1am"}`
* 14 would become `{:ok, "2pm"}`
* If the value given is less than 1 return `{:error, :time_too_low}`.
* If the value given is greater than 24 return `{:error, :time_too_high}`

## Unexpected Errors

While we can do our best to predict errors, it's truly impossible to predict them all. Some
errors are not within our control, such as the malfunction of physical hardware, some errors
result out of unexpected complexity and behavior.

Some errors result because of external systems, or malformed data, and some errors are because
we spelled **accelleration** with one **l** instead of two. 🤦‍♂️

Whatever the reason, unpredictable errors happen. Infact, 
Elixir has a philosophy of "Let it crash" which you'll learn more about in future lessons.

There are two main categories of errors. The first is a [RuntimeError](https://hexdocs.pm/elixir/1.13.2/RuntimeError.html).
A runtime error occurs while the program is running. That's why it's called a runtime error.

The other is a [CompileError](https://hexdocs.pm/elixir/1.13.2/CompileError.html)
. A compile error occurs during compile time. 
What is compile time? Compile time when the Elixir source code that you've written gets converted
into binary machine code instructions for the computer.

Elixir is a **compiled** language, so it's instructions get compiled into binary machine code before being
run. Alternatively, some languages are **interpreted**. Interpreted languages get converted into computer instruction as
they run rather than upfront.

Whenever you encounter an error, Elixir attempts to provide information about what
happened by raising an error.

What does **raise** an error mean? You may have noticed Elixir provides a variety of errors that help you understand what
went wrong in your program. Whenever Elixir encounters an error, it stops the current execution and displays an error.

You can manually raise a **RuntimeError** error with the `raise` keyword.

```elixir
raise "Oh no!"
```

You can also trigger a **CompileError** by writing some invalid Elixir syntax. Because Elixir
is compiled, it's able to pre-determine that the code is invalid before running it.

```elixir
you(cannot(just(write(anything))))
```

You've already been introduced to several other kinds of errors. It's not important
that you remember all of them, but you should try to understand what they mean when you see them.

* **FunctionClauseError**: a function is called with input that doesn't match any clause. i.e `Date.new("", "", "")`
* **ArithmeticError**: when you misuse an arithmetic operator i.e. `1 + ""`
* **TokenMissingError**: when you don't complete an expression i.e. `1 +`

These are all runtime errors that occur under specific conditions.
They help you determine the cause of your error better than a generic **RuntimeError**.

<!-- livebook:{"break_markdown":true} -->

```mermaid
flowchart LR
RuntimeError --> FunctionClauseError
RuntimeError --> ArithmeticError
RuntimeError --> TokenMissingError
```

<!-- livebook:{"break_markdown":true} -->

### Try/Rescue

When executing code that could result in an error, you case use `try` and `rescue` to prevent it from crashing
the entire program's execution. The code in the `try` block will run, and if it results in an error,
then the `rescue` block will run. the `rescue` block works like a `case` statement where you can
pattern match on the error from the `try` block.

```elixir
try do
  raise "oh no!"
rescue
  _ -> "that's better"
end
```

In the above example we pattern match using the default case with underscore `_`.
You could instead match on the specific error **RuntimeError**

```elixir
try do
  raise "oh no!"
rescue
  RuntimeError -> "that's better"
end
```

Infact, you have the ability to decide which type of error to `raise`.

```elixir
try do
  raise ArithmeticError, "Math can be hard sometimes"
rescue
  ArithmeticError -> "Fortunately you have support!"
end
```

It's convention in Elixir to use bang `!` in the name of a function that expects to raise an error.
For example, there's an alternative to `Date.new/4` called `Date.new!/4`. Instead of returning an
`:ok` or `:error` tuple it either returns a date, or raises an error.

```elixir
Date.new!(1982, 06, 29)
```

```elixir
Date.new!(11982, 06, 29)
```

### Your Turn

<!-- livebook:{"break_markdown":true} -->

In the Elixir cell below, `raise` a **TokenMissingError**

```elixir

```

In the Elixir cell below

* Create a `try`/`rescue` block.
* Cause a **SyntaxError** in the try block.
* Handle the **SyntaxError** in the rescue block and return `"phew!"` .

```elixir

```
