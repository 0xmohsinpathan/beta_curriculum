# Book Search: Tags

```elixir
Mix.install([
  {:kino, github: "livebook-dev/kino", override: true},
  {:kino_lab, "~> 0.1.0-dev", github: "jonatanklosko/kino_lab"},
  {:vega_lite, "~> 0.1.4"},
  {:kino_vega_lite, "~> 0.1.1"},
  {:benchee, "~> 0.1"},
  {:ecto, "~> 3.7"},
  {:math, "~> 0.7.0"},
  {:faker, "~> 0.17.0"},
  {:utils, path: "utils"},
  {:httpoison, "~> 1.8"},
  {:poison, "~> 5.0"}
])
```

## Navigation

[Return Home](../start.livemd)<span style="padding: 0 30px"></span>
[Report An Issue](https://github.com/DockYard-Academy/beta_curriculum/issues/new)

## Setup

Ensure you type the `ea` keyboard shortcut to evaluate all Elixir cells before starting. Alternatively, you can evaluate the Elixir cells as you read.

## Overview

We will add tags to our `BookSearch` application from the previous lesson.
If you need clarification during this reading, you can reference the completed [BookSearch with Categories] project.

Tags describe the type of book. For example we might have `"fiction"` or `"history"` tags.

Books can have multiple tags. For example, a book might have both the `"action"` tag and the `"comic book"` tag.
Tags can also have multiple books. For example, We want to be able to query books that have the `"action"` tag.

Books and Tags have a **many-to-many** to many relationship.

In order to model many-to-many relationships each resource belongs in it's own table, and then we use another table often called a **join-through** table to associate one resource with another.

### books table

| id  | name                |
| --- | ------------------- |
| 123 | "Name of the Wind"  |
| 124 | "A Wise Man's Fear" |

### tags table

| id  | name      |
| --- | --------- |
| 123 | "fiction" |

### book_tags table

| id | book_id | tag_id |
| -- | ------- | ------ |
| 1  | 123     | 456    |
| 1  | 124     | 456    |

This way tags can have many books, and books can have many tags.

<!-- livebook:{"break_markdown":true} -->

```mermaid
classDiagram
  direction RL
  class Book {
    title: :string
    tags: [Tag]
  }

  class Tag {
    name: :string
    books: [Book]
  }

  class BookTag {
    book_id: :id
    tag_id: :id
  }

  Book "*" --> "*" BookTag :has_many
  Tag "*" --> "*" BookTag :has_many
```

The `"book_tags"` table stores a foreign key to both the book and the tag.
We can query this table to find all of the tags for a book, and all of the books for a tag.

## Run Book Search Project

Ensure you have completed the `BookSearch` project from the previous lesson. If not, you can clone the [BookSearch](https://github.com/BrooklinJazz/book_search/tree/books) project on the `books` branch.

All tests should pass.

```
$ mix test
```

Start the server.

```
$ mix phx.server
```

## Books Tags Table

We can run the following to create our tags resource.

```
$ mix phx.gen.html Tags Tag tags name:string
```

Then add the `"/tags"` resource to our router.

<!-- livebook:{"force_markdown":true} -->

```elixir
  scope "/", BookSearchWeb do
    pipe_through :browser

    get "/", PageController, :index

    resources "/authors", AuthorController do
      resources "/books", BookController
    end

    get "/books", BookController, :index

    resources "/tags", TagController
  end
```

Run migrations.

```
$ mix ecto.migrate
```

All tests should pass.

```
$ mix test
```

Now we can perform standard CRUD actions for tags when we visit http://localhost:4000/tags

## Associating Tags and Books

To associate Tags and Books we need to add join table.
This table will store a reference (a foreign key) to both the books and the tags tables.

We can generate `"book_tags"` table migration with the following. We don't need to generate a context or controller for the join
table.

```
$ mix ecto.gen.migration create_book_tags
```

Now we need to create our migration in the generated migration `priv/repo/migrations/_create_book_tags.exs` file.
The `:book_tags` table should contain a reference to `:book_id` and `:tag_id`. If either the book or the tag is deleted we want to delete the association.
We also want to enforce that both the `:book_id` and `:tag_id` cannot be null.

The `create unique_index(:book_tags, [:book_id, :tag_id])` ensures we don't associate a book with the same tag multiple times. Each association must be unique.

<!-- livebook:{"force_markdown":true} -->

```elixir
defmodule BookSearch.Repo.Migrations.CreateBookTags do
  use Ecto.Migration

  def change do
    create table(:book_tags) do
      add :book_id, references(:books, on_delete: :delete_all), null: false
      add :tag_id, references(:tags, on_delete: :delete_all), null: false

      create unique_index(:book_tags, [:book_id, :tag_id])
    end
  end
end
```

## Selecting Tags

When we create a book, we want to be able to associate the book with selected tags.

Ideally, clients should be able to select from a list of the existing tags.

Phoenix provides a [Phoenix.HTML.Form.multiple_select/4](https://hexdocs.pm/phoenix_html/Phoenix.HTML.Form.html#multiple_select/4)
input we can use to select tags when creating a book. Add this select input to the book form.

```elixir
# lib/book_search_web/templates/book/form.html.heex

<.form let={f} for={@changeset} action={@action}>
  <%= if @changeset.action do %>
    <div class="alert alert-danger">
      <p>Oops, something went wrong! Please check the errors below.</p>
    </div>
  <% end %>

  <%= label f, :title %>
  <%= text_input f, :title %>
  <%= error_tag f, :title %>

  <%= label f, :tags %>
  <%= multiple_select f, :tags, [] %>
  <%= error_tag f, :tags %>

  <div>
    <%= submit "Save" %>
  </div>
</.form>
```

Visit http://localhost:4000/authors/1/books/new where `1` is the id of an author in your application, and we should see the following. The `multiple_select/4` input currently has no options because we haven't provided them.

<!-- livebook:{"break_markdown":true} -->

![](images/new_book_with_tag_blank_form.png)

<!-- livebook:{"break_markdown":true} -->

We need to provide the tags to the template from the controller to display the tag options.
`alias` the `BookSearch.Tags` module. add `alias BookSearch.Tags` to our existing aliases.

<!-- livebook:{"force_markdown":true} -->

```elixir
# lib/book_search_web/controllers/book_controller.ex

  alias BookSearch.Books
  alias BookSearch.Tags
  alias BookSearch.Books.Book
```

Now we can use the `Tags` module to retrieve all tags in the `BookController.new/2` action.

<!-- livebook:{"force_markdown":true} -->

```elixir
# lib/book_search_web/controllers/book_controller.ex

def new(conn, %{"author_id" => author_id}) do
  tags = Tags.list_tags()
  changeset = Books.change_book(%Book{})
  render(conn, "new.html", changeset: changeset, author_id: author_id, tags: tags)
end
```

Options to the `multiple_select/4` input are passed in as a keyword list of labels and values.

<!-- livebook:{"force_markdown":true} -->

```elixir
# lib/book_search_web/templates/book/form.html.heex

<%= multiple_select f, :tags, ["label": "value"] %>
```

We want the label to be the name of the tag, and the value to be the tag's id.

We can map over the `@tags` to create the keyword list.

<!-- livebook:{"force_markdown":true} -->

```elixir
# lib/book_search_web/templates/book/form.html.heex

<%= multiple_select f, :tags, Enum.map(@tags, fn %{id: id, name: name} -> {name, id} end), selected: [] %>
```

## Seeding

We haven't created any tags, so the text input is still empty, however this is a great opportunity to demonstrate the value of seeding.

Seeding is the initial creation of data in your database typically run before your tests or to create a convenient developer environment. Though, you can seed in a production or other environment as well.

It would be convenient to create several authors, books, and tags in our development environment programatically through a seed file. This way we can explore and test features in our application without needing to do any manual setup.

Fortunately, Phoenix provides a `priv/repo/seeds.exs` where we can seed data in our development and test environment.

Add the following content to `priv/repo/seeds.exs`.

<!-- livebook:{"force_markdown":true} -->

```elixir
alias BookSearch.Tags
alias BookSearch.Authors
alias BookSearch.Books

if Mix.env() == :dev do
  {:ok, author1} = BookSearch.Authors.create_author(%{name: "Patrick Rothfuss"})
  {:ok, author2} = BookSearch.Authors.create_author(%{name: "Dennis E Taylor"})

  BookSearch.Books.create_book(%{name: "Name of the Wind", author: author1})
  BookSearch.Books.create_book(%{name: "We are Legend (We are Bob)", author: author2})

  ["fiction", "fantasy", "history", "sci-fi"]
  |> Enum.each(fn tag_name ->
    BookSearch.Tags.create_tag(%{name: tag_name})
  end)
end
```

For the most part, this code should look familiar other than perhaps `Mix.env() == :dev`.
`Mix.env()` returns the current environment. When we run tests `Mix.env()` returns `:test`. When we run the applicatiohn locally `Mix.env()` returns `:dev`. We've added this condition to avoid seeding data in our tests, which could cause unexpected behavior.

We can seed our database by running the following. Make sure you stop the server first, otherwise the command will fail.

```
$ mix run priv/repo/seeds.exs
```

However, keep in mind if we keep running this file, we'll keep creating duplicate values in the database. We currently don't prevent two authors having the same name.

To avoid this issue, we can instead run the following command to first drop the database, recreate an empty database, run migrations, and then run the seed file.

```
$ mix ecto.reset
```

This command is defined in our `mix.exs` file in the `aliases/0` function.

<!-- livebook:{"force_markdown":true} -->

```elixir
defp aliases do
  [
    setup: ["deps.get", "ecto.setup"],
    "ecto.setup": ["ecto.create", "ecto.migrate", "run priv/repo/seeds.exs"],
    "ecto.reset": ["ecto.drop", "ecto.setup"],
    test: ["ecto.create --quiet", "ecto.migrate --quiet", "test"],
    "assets.deploy": ["esbuild default --minify", "phx.digest"]
  ]
end
```

After running `mix ecto.reset` our database is properly seeded. Start the server again and we should see the following when we visit http://localhost:4000/authors/1/books/new.

<!-- livebook:{"break_markdown":true} -->

![](images/new_book_with_seeded_tags.png)

## Create Book Tags

Submitting our form doesn't associate a book with a tag. However, it does provide the data we need to the controller action.

Here's the `book_params` value in `BookController.create/2` when we submit the form with the first three tags selected.

<!-- livebook:{"force_markdown":true} -->

```elixir
%{"tags" => ["1", "2", "3"], "title" => ""}
```

Feel free to `IO.inspect/2` the `book_params` in `BookController.create/2`, then create a book with tags selected to verify this is true.

<!-- livebook:{"force_markdown":true} -->

```elixir
# lib/book_search_web/controllers/book_controller.ex

def create(conn, %{"book" => book_params, "author_id" => author_id}) do
  IO.inspect(book_params, label: "Book Params") # <- remove this IO.inspect when you are done
  author = BookSearch.Authors.get_author!(author_id)

  case Books.create_book(Map.put(book_params, :author, author)) do
    {:ok, book} ->
      conn
      |> put_flash(:info, "Book created successfully.")
      |> redirect(to: Routes.author_book_path(conn, :show, author_id, book))

    {:error, %Ecto.Changeset{} = changeset} ->
      render(conn, "new.html", changeset: changeset, author_id: author_id)
  end
end
```

### Books.create_book/1

Now that we know we can send a list of tags, let's start writing a test for the `Books.create_book/1` function. First, import the `BookSearch.TagsFixtures` into the test file. This gives us access to the `tag_fixture/1` fuction to create tags in our tests.

<!-- livebook:{"force_markdown":true} -->

```elixir
# test/book_search/books_test.exs

import BookSearch.BooksFixtures
import BookSearch.AuthorsFixtures
import BookSearch.TagsFixtures
```

Write a new `"create_book/1 with tags"` test.

<!-- livebook:{"force_markdown":true} -->

```elixir
test "create_book/1 with tags" do
  author = author_fixture()
  tag1 = tag_fixture()
  tag2 = tag_fixture()
  valid_attrs = %{title: "some title", author: author, tags: [tag1, tag2]}

  assert {:ok, %Book{} = book} = Books.create_book(valid_attrs)
  assert book.title == "some title"
  assert book.tags == [tag1, tag2]
end
```

We can use [Ecto.Changeset.put_assoc/4](https://hexdocs.pm/ecto/Ecto.Changeset.html#put_assoc/4)
to create the association between the book and the tags.

> The `Ecto.Changeset.put_assoc/4` call should be the responsibility of the `Book` schema. We're calling `Ecto.Changeset.put_assoc/4` directly for demonstration purposes only.

<!-- livebook:{"force_markdown":true} -->

```elixir
def create_book(attrs \\ %{}) do
  {author, attrs} = Map.pop!(attrs, :author)

  author
  |> Ecto.build_assoc(:books, attrs)
  |> Book.changeset(attrs)
  |> Ecto.Changeset.put_assoc(:tags, attrs.tags)
  |> Repo.insert()
end
```

To let `Ecto` handle this association with `put_assoc/4`, we need to tell the `Book` schema about the many to many relationship. The [many_to_many/3](https://hexdocs.pm/ecto/Ecto.Schema.html#many_to_many/3) macro lets us define the `:tags` field, the `Tag` struct value, and to join through the `"book_tags"` table.

<!-- livebook:{"force_markdown":true} -->

```elixir
defmodule BookSearch.Books.Book do
  use Ecto.Schema
  import Ecto.Changeset

  schema "books" do
    field :title, :string
    belongs_to :author, BookSearch.Authors.Author
    many_to_many :tags, BookSearch.Tags.Tag, join_through: "book_tags"

    timestamps()
  end

  @doc false
  def changeset(book, attrs) do
    book
    |> cast(attrs, [:title])
    |> validate_required([:title])
  end
end
```

Now our test should pass! Run the following in the command line where `40` is the correct line number of the test.

```
$ mix test test/book_search/books_test.exs:40
...
9 tests, 0 failures, 8 excluded
```

However, if we visit http://localhost:4000/authors/1/books/new and submit the form with tags selected, we'll see the following error.

<!-- livebook:{"break_markdown":true} -->

![](images/key_tags_not_found.png)

<!-- livebook:{"break_markdown":true} -->

That's because `Books.create_book/1` expectes `attrs` to contain a `:tag` field that is a list of tags. Instead, we're passing it a `"tags"` field that is a list of tag ids.

Let's retrieve the tag for each tag id, and `Map.put/2` the `:tags` field into the `book_params` map. Also, we'll provide a default value for tags to avoid breaking existing controller tests.

<!-- livebook:{"force_markdown":true} -->

```elixir
def create(conn, %{"book" => book_params, "author_id" => author_id}) do
  author = BookSearch.Authors.get_author!(author_id)
  # Provide a default value for tag_ids to avoid breaking existing tests
  {tag_ids, book_params} = Map.pop(book_params, "tags", [])
  tags = Enum.map(tag_ids, &Tags.get_tag!/1)

  book_params = book_params |> Map.put(:author, author) |> Map.put(:tags, tags)

  case Books.create_book(book_params) do
    {:ok, book} ->
      conn
      |> put_flash(:info, "Book created successfully.")
      |> redirect(to: Routes.author_book_path(conn, :show, author_id, book))

    {:error, %Ecto.Changeset{} = changeset} ->
      render(conn, "new.html", changeset: changeset, author_id: author_id)
  end
end
```

We're not allowed to pass a map with both string keys and atom keys to `Ecto.Changeset.cast/4`, so let's `Map.pop/2` the `:tags` field in `Books.create_book/1`.

<!-- livebook:{"force_markdown":true} -->

```elixir
def create_book(attrs \\ %{}) do
  {author, attrs} = Map.pop!(attrs, :author)
  {tags, attrs} = Map.pop(attrs, :tags, [])

  author
  |> Ecto.build_assoc(:books, attrs)
  |> Book.changeset(attrs)
  |> Ecto.Changeset.put_assoc(:tags, tags)
  |> Repo.insert()
end
```

Now our test should pass! Run the following and replace `40` with the correct line number of the test.

```
$ mix test test/book_search/books_test.exs:40
...
9 tests, 0 failures, 8 excluded
```

```elixir
2 + 2
```
