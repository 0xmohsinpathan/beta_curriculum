# Phoenix APIs

```elixir
Mix.install([
  {:kino, github: "livebook-dev/kino", override: true},
  {:kino_lab, "~> 0.1.0-dev", github: "jonatanklosko/kino_lab"},
  {:vega_lite, "~> 0.1.4"},
  {:kino_vega_lite, "~> 0.1.1"},
  {:benchee, "~> 0.1"},
  {:ecto, "~> 3.7"},
  {:math, "~> 0.7.0"},
  {:faker, "~> 0.17.0"},
  {:utils, path: "utils"},
  {:httpoison, "~> 1.8"},
  {:poison, "~> 5.0"}
])
```

## Navigation

[Return Home](../start.livemd)<span style="padding: 0 30px"></span>
[Report An Issue](https://github.com/DockYard-Academy/beta_curriculum/issues/new)

## Setup

Ensure you type the `ea` keyboard shortcut to evaluate all Elixir cells before starting. Alternatively you can evaluate the Elixir cells as you read.

## Overview

The Phoenix Framework is the most popular web development framework for Elixir. Using Phoenix, we can build rich interactive web applications quickly.To get a better understanding of the power of Phoenix, Here's how you can create a chat application in 8 minutes.

```elixir
Kino.YouTube.new("ZUNzXbIP_FQ")
```

Now that you've seen how powerful Phoenix can be, we're going to walk through creating a Phoenix API from scratch to get a better understanding of how Phoenix works.

## Install Phoenix

In order to use Phoenix, we need to install it and several prerequisite programs.
At this point in the course, you should already have Erlang, Elixir, and Postgres installed.

You'll also need to install the Hex package manager. [Hex](https://hex.pm/) manages elixir dependencies.

```sh
$ mix local.hex
```

Install the `phx_new` dependency which we'll use to generate a phoenix project.

```sh
$ mix archive.install hex phx_new
```

Phoenix projects use Live Reloading to automatically reload the project anytime a project file changes.
macOS and Windows users will have this by default, but Linux users or Windows users students using WSL need to
install inotify-tools to use this feature.

Consult the [inotify-tools](https://github.com/inotify-tools/inotify-tools/wiki) documentation for installation instructions.
This is technically optional, but highly recommended.

If you have any issues, consult the [Phoenix Installation Guide](https://hexdocs.pm/phoenix/installation.html) and speak with
your teacher.

## Create a Pheonix App

The `phx_new` dependency provides the `mix phx.new` task which we can use to generate a new phoenix project.
We're going to create a counter server that will track an integer we can increment using HTTP requests.

Run the following in your command line to create a new phoenix project.

```
mix phx.new counter --no-ecto
```

The `--no-ecto` command omits the ecto database, which we will not need for this lesson.

When prompted to install dependencies, type `Y` and press enter.
This runs `mix deps.get` and `mix deps.compile`.

```
Fetch and install dependencies? [Yn] Y 
* running mix deps.get
* running mix deps.compile
```

## Project Structure

Open the new `counter` project in your code editor.
Phoenix projects use [Mix](./mix.livemd), so this folder structure should feel familiar, but includes a few extra or modified files.

```
├── _build
├── assets
├── config
├── deps
├── lib
│   ├── counter
│   ├── counter.ex
│   ├── counter_web
│   └── counter_web.ex
├── priv
├── test
├── formatter.exs
├── .gitignore
├── mix.exs
├── mix.lock
└── README.md
```

For a complete overview of each file and folder, see the Phoenix Documentation on [Directory Structure](https://hexdocs.pm/phoenix/directory_structure.html).
We'll walk through the purpose of each folder and file as they become relevant to our counter project.

First, we'll focus on the `/lib` folder which contains our application code.
`/lib` is split into two subdirectories, one for the business logic of our application, and one that handles the web server side of our application.

For example, in the `counter` project, there should be a `/lib/counter` folder and a `lib/counter_web` folder.
`/lib/counter` will hold the business logic of our counter such as storing and incrementing the count. The `lib/counter_web`
folder will hold the web related logic for our counter such as creating a web server, accepting requests from clients, and responding to requests from clients.

## Start Phoenix

We can start the Phoenix web server by running the following command from the `/counter` folder in your command line.

```sh
$ mix phx.server
```

When you start a Phoenix project, it runs the `Counter.Application.start/2` function in `lib/counter/application.ex` which starts several workers under a supervisor.

```elixir
def start(_type, _args) do
  children = [
    # Start the Ecto repository
    Counter.Repo,
    # Start the Telemetry supervisor
    CounterWeb.Telemetry,
    # Start the PubSub system
    {Phoenix.PubSub, name: Counter.PubSub},
    # Start the Endpoint (http/https)
    CounterWeb.Endpoint
    # Start a worker by calling: Counter.Worker.start_link(arg)
    # {Counter.Worker, arg}
  ]

  # See https://hexdocs.pm/elixir/Supervisor.html
  # for other strategies and supported options
  opts = [strategy: :one_for_one, name: Counter.Supervisor]
  Supervisor.start_link(children, opts)
end
```

The `CounterWeb.Endpoint` module is the boundary where all requests to your application start. Now that the Phoenix server is running, we
can visit http://localhost:4000 to view the Phoenix home page.

<!-- livebook:{"break_markdown":true} -->

![](images/phoenix_main_page.png)

<!-- livebook:{"break_markdown":true} -->

Phoenix uses the [Plug](https://hexdocs.pm/plug/readme.html) library which is a specification for composing web applications using functions. Ultimately, Phoenix calls a series of functions to transform a [Plug.Conn](https://hexdocs.pm/plug/Plug.Conn.html) struct and return a response back to the client.

A few things happen when we navigate to http://localhost:4000.

1. The browser makes an HTTP GET request.
2. The `CounterWeb.Endpoint` module in `lib/counter_web/endpoint.ex` creates an initial [Plug.Conn](https://hexdocs.pm/plug/Plug.Conn.html) struct which will be transformed in a pipeline of functions.
3. The `CounterWeb.Router` module in `lib/counter_web/router.ex` routes the request to a controller.
4. The `CounterWeb.PageController` module in `lib/counter_web/controllers/page_controller.ex` module handles the request and response, and delegates to a view to render the response.
5. The `CounterWeb.PageView` module in `lib/counter_web/views/page_view.ex` renders a response using a template `.heex` file.
6. The template in `index.html.heex` uses the Phoenix template language HEEx (HTML + EEX) to build an HTML web page which will be the response to GET request.
7. The HTML response is sent back to the browser.

<!-- livebook:{"break_markdown":true} -->

```mermaid
sequenceDiagram
  autonumber
  participant B as Browser
  participant E as Endpoint
  participant R as Router
  participant C as Controller
  participant V as View
  participant T as Template

  B->>E: GET Request
  E->>R: Set Up Plug Pipeline with Conn
  R->>C: Route Request to Controller
  C->>V: Handle request and delegate to View
  V->>T: Build response using template
  T->>E: Build HTML web page
  E->>B: HTML response sent back to browser.
```

## Router

In order to handle an HTTP request from the client we need to define a route.

Routes accept incoming client requests provided a particular path and determine how to return a response to the client. Routes are defined in the `lib/counter_web/router.ex` file.

The [Phoenix.Router](https://hexdocs.pm/phoenix/Phoenix.Router.html) module defines several macros for handling HTTP requests.

* [post/4](https://hexdocs.pm/phoenix/Phoenix.Router.html#post/4) handle an HTTP POST request.
* [get/4](https://hexdocs.pm/phoenix/Phoenix.Router.html#get/4) handle an HTTP GET request.
* [resources/2](https://hexdocs.pm/phoenix/Phoenix.Router.html#resources/2) handle a standard matrix of HTTP requests.

The initial `router.ex` file has many macros such as `scope/3`, `pipeline/3`, `plug/2`, `pipe_through/1` and `get/3`.

<!-- livebook:{"break_markdown":true} -->

<!-- livebook:{"force_markdown":true} -->

```elixir
defmodule CounterWeb.Router do
  use CounterWeb, :router

  pipeline :browser do
    plug :accepts, ["html"]
    plug :fetch_session
    plug :fetch_live_flash
    plug :put_root_layout, {CounterWeb.LayoutView, :root}
    plug :protect_from_forgery
    plug :put_secure_browser_headers
  end

  pipeline :api do
    plug :accepts, ["json"]
  end

  scope "/", CounterWeb do
    pipe_through :browser

    get "/", PageController, :index
  end

  # Other scopes may use custom stacks.
  # scope "/api", CounterWeb do
  #   pipe_through :api
  # end

  # Enables LiveDashboard only for development
  #
  # If you want to use the LiveDashboard in production, you should put
  # it behind authentication and allow only admins to access it.
  # If your application does not have an admins-only section yet,
  # you can use Plug.BasicAuth to set up some basic authentication
  # as long as you are also using SSL (which you should anyway).
  if Mix.env() in [:dev, :test] do
    import Phoenix.LiveDashboard.Router

    scope "/" do
      pipe_through :browser

      live_dashboard "/dashboard", metrics: CounterWeb.Telemetry
    end
  end

  # Enables the Swoosh mailbox preview in development.
  #
  # Note that preview only shows emails that were sent by the same
  # node running the Phoenix server.
  if Mix.env() == :dev do
    scope "/dev" do
      pipe_through :browser

      forward "/mailbox", Plug.Swoosh.MailboxPreview
    end
  end
end
```

<!-- livebook:{"break_markdown":true} -->

By default, the router defines a `:browser` pipeline for handling requests using a browser, and an `:api` pipeline for handling HTTP requests.

Our GET request from the browser hits the following route. The `scope/3` macro defines a base url `"/"` and automatically aliases all controllers so we can use `PageController` instead of `CounterWeb.PageController`.

<!-- livebook:{"force_markdown":true} -->

```elixir
scope "/", CounterWeb do
  pipe_through :browser

  get "/", PageController, :index
end
```

The `pipe_through :browser` macro calls all of the plugs inside of the `:browser` pipeline. This handles some necessary boilerplate code including security features and rendering a root layout in `lib/counter_web/templates/root.html.heex` shared by every page.

<!-- livebook:{"force_markdown":true} -->

```elixir
  pipeline :browser do
    plug :accepts, ["html"]
    plug :fetch_session
    plug :fetch_live_flash
    plug :put_root_layout, {CounterWeb.LayoutView, :root}
    plug :protect_from_forgery
    plug :put_secure_browser_headers
  end
```

The `get/3` macro sets up a route `"/"` which is for http://localhost:4000/. It then delegates to the `PageController.index/2` function.

For our counter application, we're going to set up our own `"/counter"` route which will return a count response to the user.

<!-- livebook:{"force_markdown":true} -->

```elixir
scope "/", CounterWeb do
  pipe_through :browser

  get "/", PageController, :index
  get "/count", CounterController, :index
end
```

We can run  following command to see all of the defined routes in a project. We should see the new `/counter` route.

```
$ mix phx.routes
          page_path  GET  /                                      CounterWeb.PageController :index
       counter_path  GET  /count                                 CounterWeb.CounterController :index
live_dashboard_path  GET  /dashboard                             Phoenix.LiveDashboard.PageLive :home
live_dashboard_path  GET  /dashboard/:page                       Phoenix.LiveDashboard.PageLive :page
live_dashboard_path  GET  /dashboard/:node/:page                 Phoenix.LiveDashboard.PageLive :page
                     *    /dev/mailbox                           Plug.Swoosh.MailboxPreview []
          websocket  WS   /live/websocket                        Phoenix.LiveView.Socket
           longpoll  GET  /live/longpoll                         Phoenix.LiveView.Socket
           longpoll  POST  /live/longpoll                         Phoenix.LiveView.Socket
```

<!-- livebook:{"break_markdown":true} -->

Now when we visit http://localhost/count we'll see the following error.

<!-- livebook:{"break_markdown":true} -->

![](images/counter_controller_is_not_available.png)

## Controllers

A controller determines the response to send back to a user.

The `CounterWeb.PageController` in `lib/counter_web/controllers/page_controller.ex` calls the `render/3` macro which delegates to a view to render some HTML.

<!-- livebook:{"force_markdown":true} -->

```elixir
defmodule CounterWeb.PageController do
  use CounterWeb, :controller

  def index(conn, _params) do
    render(conn, "index.html")
  end
end
```

Notice that the function name `index/2` matches the atom defined in the router.

<!-- livebook:{"force_markdown":true} -->

```elixir
get "/", PageController, :index
```

To make our counter, we need to define a controller. Create a file `lib/counter_web/controllers/counter_controller.ex` with the following content.

<!-- livebook:{"force_markdown":true} -->

```elixir
defmodule CounterWeb.CounterController do
  use CounterWeb, :controller

  
  def index(conn, _params) do
  end
end
```

The router calles this `CounterController.index/2` function to handle the request and response.

The first argument in the `index/2` function is the [Plug.Conn](https://hexdocs.pm/plug/Plug.Conn.html) being transformed by the plug pipeline.

The second argument is a map of any query parameters included in the request.

The [Phoenix.Controller](https://hexdocs.pm/phoenix/Phoenix.Controller.html) module provides several macros to return a response to the user. Here are a few of the most commonly used.

* [html/2](https://hexdocs.pm/phoenix/Phoenix.Controller.html#html/2) return a manual HTML response.
* [json/2](https://hexdocs.pm/phoenix/Phoenix.Controller.html#json/2) return JSON.
* [redirect](https://hexdocs.pm/phoenix/Phoenix.Controller.html#redirect/2) redirect the client to another url.
* [render/3](https://hexdocs.pm/phoenix/Phoenix.Controller.html#render/3) return HTML from a template file.
* [text/2](https://hexdocs.pm/phoenix/Phoenix.Controller.html#text/2) return a text string.

For example, we can use the `text/2` macro to return a text response.

<!-- livebook:{"force_markdown":true} -->

```elixir
defmodule CounterWeb.CounterController do
  use CounterWeb, :controller

  def index(conn, _params) do
    text(conn, "Hello, world!")
  end
end
```

Now when we visit http://localhost:4000/count we should see the `"Hello, world!"` response.

<!-- livebook:{"break_markdown":true} -->

### Your Turn

Use the `text/2`, `html/2`, `json/2`, and `redirect/2` macros to return a response from your `CounterController.index/2` function. You may copy-paste each of the following examples one at a time.

<!-- livebook:{"force_markdown":true} -->

```elixir
text(conn, "Hello, world!")
html(conn, "<h1>Hello, world!</h1>")
json(conn, %{"key" => "value"})
redirect(conn, to: "/")
redirect(conn, external: "https://elixir-lang.org")
```

Feel free to experiment with these macros to better understand them.

<!-- livebook:{"break_markdown":true} -->

### Query Params

Query params are conveniently converted into an Elixir map before reaching the controller.
For example, if you visit http://localhost:4000?message=hello the second argument to
`index/2` will be `%{"message" => "hello"}`.

Let's verify this, now our `index/2` function will return the `"message"` query parameter if it exists, and otherwise return `"Hello, world!"`.

<!-- livebook:{"force_markdown":true} -->

```elixir
defmodule CounterWeb.CounterController do
  use CounterWeb, :controller

  def index(conn, params) do
    message = Map.get(params, "message", "Hello, world!")
    text(conn, message)
  end
end
```

Now if you visit http://localhost:4000/count?message=hello the page should display `"hello"`.

## Views

While we can return a response directly in the Controller, it's conventional to use the `render/3` macro to delegate to a view to build the response.

Replace `lib/counter_web/controllers/counter_countroller.ex` with the following content.

<!-- livebook:{"force_markdown":true} -->

```elixir
defmodule CounterWeb.CounterController do
  use CounterWeb, :controller

  def index(conn, params) do
    render(conn, "index.html", count: 0)
  end
end
```

We'll see the following error if we visit http://localhost:4000/count

<!-- livebook:{"break_markdown":true} -->

![](images/counter_view_is_not_available.png)

<!-- livebook:{"break_markdown":true} -->

By convention, a `CounterController` expects a `CounterView` to exist. The name of the view should match the name of the controller.

Create a file `lib/counter_web/views/counter_view.ex` with the following content.

<!-- livebook:{"force_markdown":true} -->

```elixir
defmodule CounterWeb.CounterView do
  use CounterWeb, :view
end
```

Now if we visit http://localhost:4000/count we'll see the following error.

<!-- livebook:{"break_markdown":true} -->

![](images/could_not_render_index.png)

<!-- livebook:{"break_markdown":true} -->

The `CounterView` expects a matching template file to exist.

## Counter Implementation

It's time to implement our counter. Business logic belongs in the `/lib/counter` folder, so we'll create a `/lib/counter/counter_server.ex` file. This file defines a `GenServer` that stores and increments an integer.

<!-- livebook:{"force_markdown":true} -->

```elixir
defmodule Counter.CounterServer do
  use GenServer

  def start_link(_opts) do
    GenServer.start_link(__MODULE__, 0, name: __MODULE__)
  end

  @impl true
  def init(count) do
    {:ok, count}
  end

  def get do
    GenServer.call(__MODULE__, :get)
  end

  def increment do
    GenServer.cast(__MODULE__, :increment)
  end

  @impl true
  def handle_call(:get, _from, count) do
    {:reply, count, count}
  end

  @impl true
  def handle_cast(:increment, count) do
    {:noreply, count + 1}
  end
end
```

## Start the Counter Server

The `lib/counter/application.ex` defines our Elixir application and the services that are part of our application.
As we've already done with a mix project, we can start our workers and supervisors in this file.

Add the `Counter.CounterServer` module to the `start/2` function in `application.ex`.

<!-- livebook:{"force_markdown":true} -->

```elixir
  def start(_type, _args) do
    children = [
      # Start the Telemetry supervisor
      CounterWeb.Telemetry,
      # Start the PubSub system
      {Phoenix.PubSub, name: Counter.PubSub},
      # Start the Endpoint (http/https)
      CounterWeb.Endpoint,
      # Start a worker by calling: Counter.Worker.start_link(arg)
      # {Counter.Worker, arg}
      {Counter.CounterServer, []}
    ]

    # See https://hexdocs.pm/elixir/Supervisor.html
    # for other strategies and supported options
    opts = [strategy: :one_for_one, name: Counter.Supervisor]
    Supervisor.start_link(children, opts)
  end
```

Stop your server with <kbd>CTRL</kbd>+<kbd>C</kbd>. The following commands
starts your server, and compiles the project files into the IEx shell so we can interact with them manually.

```sh
$ iex -S mix phx.server
```

Call the `Counter.CounterServer` directly from the IEx shell and ensure it works as expected.

<!-- livebook:{"force_markdown":true} -->

```elixir
iex> Counter.CounterServer.get()
0
iex> Counter.CounterServer.increment()
:ok
iex> Counter.CounterServer.get()
1
```

## Connect the Counter

Now we have a working counter. We'll retrieve the count from the `CounterWeb.CounterController` then return the current count as the response to the client.

<!-- livebook:{"force_markdown":true} -->

```elixir
defmodule CounterWeb.CounterController do
  use CounterWeb, :controller

  def index(conn, _params) do
    count = Counter.CounterServer.get()
    text(conn, count)
  end
end
```

Visit http://localhost:4000 you should see the current count as the response.

You may need to restart the server to pick up this change. Enter <kbd>CTRL</kbd>+<kbd>C</kbd> to stop the server then run the following command.

```
$ mix phx.server
```

Keep in mind, that the browser executes an HTTP GET request, but we could also retrieve the count manually using `HTTPoison`. Execute the code cell below and it should return the current count.

```elixir
case HTTPoison.get("http://localhost:4000") do
  {:ok, %HTTPoison.Response{status_code: 200, body: current_count}} ->
    current_count

  {:error, error} ->
    IO.puts("Make sure you start the server and implement the CounterController.")
    error
end
```

## Increment the Count

To increment the count, we'll have clients send an HTTP POST request.

First, use the `post/4` macro to create a new post `/increment` route in `lib/counter_web/router.ex`.

<!-- livebook:{"force_markdown":true} -->

```elixir
defmodule CounterWeb.Router do
  use CounterWeb, :router

  get "/", CounterWeb.CounterController, :index
  post "/increment", CounterWeb.CounterController, :update
end
```

When a Client makes an HTTP POST request to the `/increment` route, the router delegates to the `CounterController.update/2` function. Let's define that function in `lib/counter_web/controllers/counter_controller.ex`. For now, it will increment the counter and return the current count.

<!-- livebook:{"force_markdown":true} -->

```elixir
def update(conn, _params) do
  Counter.CounterServer.increment()
  count = Counter.CounterServer.get()
  text(conn, count)
end
```

<!-- livebook:{"break_markdown":true} -->

Remember that by default, the browser sends a GET request, not a POST request. so we will see an error if we try to visit http://localhost:4000/increment

<!-- livebook:{"break_markdown":true} -->

![](images/no_route_found_for_get_increment.png)

To test our new route we can instead use HTTPPoison to manually send a POST request.

```elixir
case HTTPoison.post("http://localhost:4000/increment", "") do
  {:ok, %HTTPoison.Response{status_code: 200, body: current_count}} ->
    current_count

  {:error, error} ->
    IO.puts(
      "Make sure you start the server and implement the CounterController.update/2 function."
    )

    error
end
```

### Views

While it's possible to return the response from the Controller, it's not conventional. The Controller should be responsible for requests and responses, and the View should handle the rendering of data (typically HTML or JSON).

Let's refactor our `CounterController` to delegate to a View.

```

```

## Scope

It's common to put routes inside of a `scope/3` macro. The `scope/3` macro allows us to nest routes under a shared base URL and automatically aliases controllers so that we can use `CounterCountroller` instead of `CounterWeb.CounterController`.

<!-- livebook:{"force_markdown":true} -->

```elixir
  scope "/", CounterWeb do
    get "/", CounterController, :index
    post "/increment", CounterController, :update
  end
```

The first argument `"/"` defines the base URL. For example, if the base URL was `"/counter"` then we would need to send a GET request to http://localhost:4000/counter and a POST request to http://localhost:4000/counter/increment.

## Pipelines and Plug

Phoenix is built using the [Plug](https://hexdocs.pm/plug/readme.html) library. Plug is a specification for building web applications with functions.

## Body Params

We can send JSON parameters with our POST request.

```elixir
HTTPoison.post!("http://localhost:4000/increment", "{\"body\": \"test\"}", [
  {"Content-Type", "application/json"}
])
```

These body params are available on the `conn` struct.

<!-- livebook:{"force_markdown":true} -->

```elixir
  def update(conn, _params) do
    IO.inspect(conn.body_params)
    Counter.CounterServer.increment()
    count = Counter.CounterServer.get()
    text(conn, count)
  end
```

<!-- livebook:{"break_markdown":true} -->


