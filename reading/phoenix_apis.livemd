# Phoenix APIs

```elixir
Mix.install([
  {:kino, github: "livebook-dev/kino", override: true},
  {:kino_lab, "~> 0.1.0-dev", github: "jonatanklosko/kino_lab"},
  {:vega_lite, "~> 0.1.4"},
  {:kino_vega_lite, "~> 0.1.1"},
  {:benchee, "~> 0.1"},
  {:ecto, "~> 3.7"},
  {:math, "~> 0.7.0"},
  {:faker, "~> 0.17.0"},
  {:utils, path: "utils"},
  {:httpoison, "~> 1.8"},
  {:poison, "~> 5.0"}
])
```

## Navigation

[Return Home](../start.livemd)<span style="padding: 0 30px"></span>
[Report An Issue](https://github.com/DockYard-Academy/beta_curriculum/issues/new)

## Setup

Ensure you type the `ea` keyboard shortcut to evaluate all Elixir cells before starting. Alternatively you can evaluate the Elixir cells as you read.

## Overview

The Phoenix Framework is the most popular web development framework for Elixir. Using Phoenix, we can build rich interactive web applications quickly.To get a better understanding of the power of Phoenix, Here's how you can create a chat application in 8 minutes.

```elixir
Kino.YouTube.new("ZUNzXbIP_FQ")
```

Now that you've seen how powerful Phoenix can be, we're going to walk through creating a Phoenix API from scratch to get a better understanding of how Phoenix works.

## Install Phoenix

In order to use Phoenix, we need to install it and several prerequisite programs.
At this point in the course, you should already have Erlang, Elixir, and Postgres installed.

You'll also need to install the Hex package manager. [Hex](https://hex.pm/) manages elixir dependencies.

```sh
$ mix local.hex
```

Install the `phx_new` dependency which we'll use to generate a phoenix project.

```sh
$ mix archive.install hex phx_new
```

Phoenix projects use Live Reloading to automatically reload the project anytime a project file changes.
macOS and Windows users will have this by default, but Linux users or Windows users students using WSL need to
install inotify-tools to use this feature.

Consult the [inotify-tools](https://github.com/inotify-tools/inotify-tools/wiki) documentation for installation instructions.
This is technically optional, but highly recommended.

If you have any issues, consult the [Phoenix Installation Guide](https://hexdocs.pm/phoenix/installation.html) and speak with
your teacher.

## Create a Pheonix API

The `phx_new` dependency provides the `mix phx.new` task which we can use to generate a new phoenix project.
We're going to create a counter server that will track an integer we can increment using HTTP requests.

Run the following in your command line to create a new phoenix project.

```
mix phx.new counter --no-ecto --no-html --no-assets --no-dashboard
```

This command creates a new phoenix project. The `--no-ecto` flag omits creating a project with a database. The `--no-html` flag omits creating Hyper Text Markup Language (HTML) views and the `--no-assets` flag omits creating asset files that style those views. The `--no-dashboard` omits an admin dashboard auto generated with the default phoenix project.

We've included these flags to omit several features of phoenix, to create a more minimal project and build everything from scratch.

You should see a list of the files generated.

```
* creating counter/config/config.exs
* creating counter/config/dev.exs
* creating counter/config/prod.exs
* creating counter/config/runtime.exs
* creating counter/config/test.exs
* creating counter/lib/counter/application.ex
* creating counter/lib/counter.ex
* creating counter/lib/counter_web/views/error_helpers.ex
* creating counter/lib/counter_web/views/error_view.ex
* creating counter/lib/counter_web/endpoint.ex
* creating counter/lib/counter_web/router.ex
* creating counter/lib/counter_web/telemetry.ex
* creating counter/lib/counter_web.ex
* creating counter/mix.exs
* creating counter/README.md
* creating counter/.formatter.exs
* creating counter/.gitignore
* creating counter/test/support/conn_case.ex
* creating counter/test/test_helper.exs
* creating counter/test/counter_web/views/error_view_test.exs
* creating counter/lib/counter/mailer.ex
* creating counter/lib/counter_web/gettext.ex
* creating counter/priv/gettext/en/LC_MESSAGES/errors.po
* creating counter/priv/gettext/errors.pot
```

When prompted to install dependencies, type `Y` and press enter.
This runs `mix deps.get` and `mix deps.compile`.

```
Fetch and install dependencies? [Yn] Y
```

## Project Structure

Open the new `counter` project in your code editor.
Phoenix projects use [Mix](./mix.livemd), so this folder structure should feel familiar, but includes a few extra or modified files.

```
├── _build
├── assets
├── config
├── deps
├── lib
│   ├── counter
│   ├── counter.ex
│   ├── counter_web
│   └── counter_web.ex
├── priv
└── test
```

For a complete overview of each folder, see the Phoenix Documentation on [Directory Structure](https://hexdocs.pm/phoenix/directory_structure.html).
We'll walk through the purpose of each folder and file as they become relevant to our counter project.

First, we'll focus on the `/lib` folder which contains our application code.
`/lib` is split into two subdirectories, one for the business logic of our application, and one that handles the web server side of our application.

For example, in the `counter` project, there should be a `/lib/counter` folder and a `lib/counter_web` folder.
`/lib/counter` will hold the business logic of our counter such as storing and incrementing the count. The `lib/counter_web`
folder will hold the web related logic for our counter such as creating a web server, accepting requests from clients, and responding to requests from clients.

## Routes

You can start the phoenix web server by running the following command from the `/counter` folder.

```sh
$ mix phx.server
```

The phoenix server runs on port `4000`. Navigate to http://localhost:4000 in your browser to connect to the project as a client. The server currently responds with an error message.

In order to handle an HTTP request from the client we need to define a route.

Routes accept incoming client requests provided a particular path and determine how to return a response to the client. Routes are defined in the `lib/counter_web/router.ex` file.

The [Phoenix.Router](https://hexdocs.pm/phoenix/Phoenix.Router.html) module defines several macros for handling HTTP requests. Here are a few of the most commonly used.

* [post/4](https://hexdocs.pm/phoenix/Phoenix.Router.html#post/4) handle an HTTP POST request.
* [get/4](https://hexdocs.pm/phoenix/Phoenix.Router.html#get/4) handle an HTTP GET request.
* [resources/2](https://hexdocs.pm/phoenix/Phoenix.Router.html#resources/2) handle a standard matrix of HTTP requests.

We'll use `get/4` the macro to create a route that handles a GET request. Routes delegate to a **controller** function. Replace `router.ex` with the following contents.

<!-- livebook:{"force_markdown":true} -->

```elixir
defmodule CounterWeb.Router do
  use CounterWeb, :router

  get "/", CounterWeb.CounterController, :index
end
```

Now the `/` route is defined, but we get an error because we haven't defined the `CounterWeb.CounterController` module.

Run the following command to see all of the defined routes in a project. You should see the new `/` route.

```
$ mix phx.routes
```

## Controllers

A controller determines the response to send back to a user.

Define a `/counter_web/controllers/counter_controller.ex` file with the following content to create a controller.

<!-- livebook:{"force_markdown":true} -->

```elixir
defmodule CounterWeb.CounterController do
  use CounterWeb, :controller
end
```

Now when we visit the page, well get an error because the `index/2` function is not defined.

In `router.ex` we used the `:index` atom as the third argument to `get/4`. This atom specifies the name of the function to call in the controller.

Define an `index/2` function in `counter_controller.ex`. Functions in the controller automatically accept two arguments. The first is a [Plug.Conn](https://hexdocs.pm/plug/Plug.Conn.html) struct provided by the router, the second argument is a map of query parameters included in the request.

The [Phoenix.Controller](https://hexdocs.pm/phoenix/Phoenix.Controller.html) module provides several macros to return a response to the user. Here are a few of the most commonly used.

* [html/2](https://hexdocs.pm/phoenix/Phoenix.Controller.html#html/2) return a manual HTML response.
* [json/2](https://hexdocs.pm/phoenix/Phoenix.Controller.html#json/2) return JSON.
* [redirect](https://hexdocs.pm/phoenix/Phoenix.Controller.html#redirect/2) redirect the client to another url.
* [render/3](https://hexdocs.pm/phoenix/Phoenix.Controller.html#render/3) return HTML from a template file.
* [text/2](https://hexdocs.pm/phoenix/Phoenix.Controller.html#text/2) return a text string.

We'll use the `text/2` macro to return a text response.

<!-- livebook:{"force_markdown":true} -->

```elixir
defmodule CounterWeb.CounterController do
  use CounterWeb, :controller

  def index(conn, _params) do
    text(conn, "Hello, world!")
  end
end
```

Now when we visit http://localhost:4000 we should see the `"Hello, world!"` response.

### Your Turn

Use the `html/2`, `json/2`, and `redirect/2` macros to return a response from your `CounterController.index/2` function. You may copy-paste each of the following examples one at a time.

<!-- livebook:{"force_markdown":true} -->

```elixir
html(conn, "<h1>Hello, world!</h1>")
json(conn, %{"key" => "value"})
redirect(conn, external: "https://elixir-lang.org")
```

Feel free to experiment with these macros to better understand them.

### Query Params

Query params are conveniently converted into an Elixir map before reaching the controller.
For example, if you visit http://localhost:4000?message=hello the second argument to
`index/2` will be `%{"message" => "hello"}`.

Let's verify this, now our `index/2` function will return the `"message"` query parameter if it exists, and otherwise return `"Hello, world!"`.

<!-- livebook:{"force_markdown":true} -->

```elixir
defmodule CounterWeb.CounterController do
  use CounterWeb, :controller

  def index(conn, params) do
    message = Map.get(params, "message", "Hello, world!")
    text(conn, message)
  end
end
```

Now if you visit http://localhost:4000?message=hello the page should display `"hello"`.

## Counter Implementation

It's time to implement our counter. Business logic belongs in the `/lib/counter` folder, so we'll create a `/lib/counter/counter_server.ex` file. This file defines a `GenServer` that stores and increments an integer.

<!-- livebook:{"force_markdown":true} -->

```elixir
defmodule Counter.CounterServer do
  use GenServer

  def start_link(_opts) do
    GenServer.start_link(__MODULE__, 0, name: __MODULE__)
  end

  @impl true
  def init(count) do
    {:ok, count}
  end

  def get do
    GenServer.call(__MODULE__, :get)
  end

  def increment do
    GenServer.cast(__MODULE__, :increment)
  end

  @impl true
  def handle_call(:get, _from, count) do
    {:reply, count, count}
  end

  @impl true
  def handle_cast(:increment, count) do
    {:noreply, count + 1}
  end
end
```

## Start the Counter Server

The `lib/counter/application.ex` defines our Elixir application and the services that are part of our application.
As we've already done with a mix project, we can start our workers and supervisors in this file.

Add the `Counter.CounterServer` module to the `start/2` function in `application.ex`.

<!-- livebook:{"force_markdown":true} -->

```elixir
  def start(_type, _args) do
    children = [
      # Start the Telemetry supervisor
      CounterWeb.Telemetry,
      # Start the PubSub system
      {Phoenix.PubSub, name: Counter.PubSub},
      # Start the Endpoint (http/https)
      CounterWeb.Endpoint,
      # Start a worker by calling: Counter.Worker.start_link(arg)
      # {Counter.Worker, arg}
      {Counter.CounterServer, []}
    ]

    # See https://hexdocs.pm/elixir/Supervisor.html
    # for other strategies and supported options
    opts = [strategy: :one_for_one, name: Counter.Supervisor]
    Supervisor.start_link(children, opts)
  end
```

Stop your server with <kbd>CTRL</kbd>+<kbd>C</kbd>. The following commands
starts your server, and compiles the project files into the IEx shell so we can interact with them manually.

```sh
$ iex -S mix phx.server
```

Call the `Counter.CounterServer` directly from the IEx shell and ensure it works as expected.

<!-- livebook:{"force_markdown":true} -->

```elixir
iex> Counter.CounterServer.get()
0
iex> Counter.CounterServer.increment()
:ok
iex> Counter.CounterServer.get()
1
```

## Connect the Counter

Now we have a working counter. We'll retrieve the count from the `CounterWeb.CounterController` then return the current count as the response to the client.

<!-- livebook:{"force_markdown":true} -->

```elixir
defmodule CounterWeb.CounterController do
  use CounterWeb, :controller

  def index(conn, _params) do
    count = Counter.CounterServer.get()
    text(conn, count)
  end
end
```

Visit http://localhost:4000 you should see the current count as the response.

You may need to restart the server to pick up this change. Enter <kbd>CTRL</kbd>+<kbd>C</kbd> to stop the server then run the following command.

```
$ mix phx.server
```

Keep in mind, that the browser executes an HTTP GET request, but we could also retrieve the count manually using `HTTPoison`. Execute the code cell below and it should return the current count.

```elixir
case HTTPoison.get("http://localhost:4000") do
  {:ok, %HTTPoison.Response{status_code: 200, body: current_count}} ->
    current_count

  {:error, error} ->
    IO.puts("Make sure you start the server and implement the CounterController.")
    error
end
```

## Increment the Count

To increment the count, we'll have clients send an HTTP POST request.

First, use the `post/4` macro to create a new post `/` route in `lib/counter_web/router.ex`.

<!-- livebook:{"force_markdown":true} -->

```elixir
defmodule CounterWeb.Router do
  use CounterWeb, :router

  get "/", CounterWeb.CounterController, :index
  post "/", CounterWeb.CounterController, :update
end
```

When a Client makes an HTTP POST request to the `/` route, the router delegates to the `CounterController.update/2` function. Let's define that function in `lib/counter_web/controllers/counter_controller.ex`. For now, it will increment the counter and return the current count.

<!-- livebook:{"force_markdown":true} -->

```elixir
def update(conn, _params) do
  Counter.CounterServer.increment()
  count = Counter.CounterServer.get()
  text(conn, count)
end
```

<!-- livebook:{"break_markdown":true} -->

Remember that by default, the browser sends a GET request, not a POST request. so we will see an error if we try to visit http://localhost:4000/increment

<!-- livebook:{"break_markdown":true} -->

![](images/no_route_found_for_get_increment.png)

To test our new route we can instead use HTTPPoison to manually send a POST request.

```elixir
case HTTPoison.post("http://localhost:4000", "") do
  {:ok, %HTTPoison.Response{status_code: 200, body: current_count}} ->
    current_count

  {:error, error} ->
    IO.puts(
      "Make sure you start the server and implement the CounterController.update/2 function."
    )

    error
end
```

## Body Params

We can send JSON parameters with our POST request.

```elixir
HTTPoison.post!("http://localhost:4000/increment", "\"key\": \"value\"")
```
